// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: recast.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "recast.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace RecastIO {

namespace {

const ::google::protobuf::Descriptor* Vec3_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Vec3_reflection_ = NULL;
const ::google::protobuf::Descriptor* AxisAlignedBounds_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AxisAlignedBounds_reflection_ = NULL;
const ::google::protobuf::Descriptor* NavMeshParams_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NavMeshParams_reflection_ = NULL;
const ::google::protobuf::Descriptor* Tile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Tile_reflection_ = NULL;
const ::google::protobuf::Descriptor* OffMeshConnection_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OffMeshConnection_reflection_ = NULL;
const ::google::protobuf::Descriptor* Material_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Material_reflection_ = NULL;
const ::google::protobuf::Descriptor* Model_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Model_reflection_ = NULL;
const ::google::protobuf::Descriptor* Model_TriParms_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Model_TriParms_reflection_ = NULL;
const ::google::protobuf::Descriptor* NodeState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NodeState_reflection_ = NULL;
struct NodeStateOneofInstance {
  ::google::protobuf::int32 submodelid_;
  ::google::protobuf::int32 staticmodelid_;
  ::google::protobuf::int32 displacementid_;
}* NodeState_default_oneof_instance_ = NULL;
const ::google::protobuf::Descriptor* NavigationMesh_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NavigationMesh_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ShapeMode_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_recast_2eproto() {
  protobuf_AddDesc_recast_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "recast.proto");
  GOOGLE_CHECK(file != NULL);
  Vec3_descriptor_ = file->message_type(0);
  static const int Vec3_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec3, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec3, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec3, z_),
  };
  Vec3_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Vec3_descriptor_,
      Vec3::default_instance_,
      Vec3_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec3, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vec3, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Vec3));
  AxisAlignedBounds_descriptor_ = file->message_type(1);
  static const int AxisAlignedBounds_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AxisAlignedBounds, mins_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AxisAlignedBounds, maxs_),
  };
  AxisAlignedBounds_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AxisAlignedBounds_descriptor_,
      AxisAlignedBounds::default_instance_,
      AxisAlignedBounds_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AxisAlignedBounds, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AxisAlignedBounds, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AxisAlignedBounds));
  NavMeshParams_descriptor_ = file->message_type(2);
  static const int NavMeshParams_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavMeshParams, agentheightstand_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavMeshParams, agentheightcrouch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavMeshParams, agentradius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavMeshParams, agentclimb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavMeshParams, walkslopeangle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavMeshParams, cellsize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavMeshParams, cellheight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavMeshParams, edgemaxlength_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavMeshParams, edgemaxerror_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavMeshParams, tilesize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavMeshParams, detailsampledist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavMeshParams, detailsamplemaxerr_),
  };
  NavMeshParams_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NavMeshParams_descriptor_,
      NavMeshParams::default_instance_,
      NavMeshParams_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavMeshParams, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavMeshParams, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NavMeshParams));
  Tile_descriptor_ = file->message_type(3);
  static const int Tile_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tile, uncompressedsize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tile, compresseddata_),
  };
  Tile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Tile_descriptor_,
      Tile::default_instance_,
      Tile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Tile));
  OffMeshConnection_descriptor_ = file->message_type(4);
  static const int OffMeshConnection_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OffMeshConnection, entrypos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OffMeshConnection, exitpos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OffMeshConnection, vertices_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OffMeshConnection, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OffMeshConnection, areaflags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OffMeshConnection, bidirectional_),
  };
  OffMeshConnection_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OffMeshConnection_descriptor_,
      OffMeshConnection::default_instance_,
      OffMeshConnection_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OffMeshConnection, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OffMeshConnection, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OffMeshConnection));
  Material_descriptor_ = file->message_type(5);
  static const int Material_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Material, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Material, contents_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Material, surfaceflags_),
  };
  Material_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Material_descriptor_,
      Material::default_instance_,
      Material_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Material, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Material, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Material));
  Model_descriptor_ = file->message_type(6);
  static const int Model_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Model, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Model, modelcrc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Model, nummeshtris_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Model, triangles_),
  };
  Model_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Model_descriptor_,
      Model::default_instance_,
      Model_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Model, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Model, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Model));
  Model_TriParms_descriptor_ = Model_descriptor_->nested_type(0);
  static const int Model_TriParms_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Model_TriParms, tri_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Model_TriParms, surfaceoverride_),
  };
  Model_TriParms_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Model_TriParms_descriptor_,
      Model_TriParms::default_instance_,
      Model_TriParms_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Model_TriParms, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Model_TriParms, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Model_TriParms));
  NodeState_descriptor_ = file->message_type(7);
  static const int NodeState_offsets_[12] = {
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(NodeState_default_oneof_instance_, submodelid_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(NodeState_default_oneof_instance_, staticmodelid_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(NodeState_default_oneof_instance_, displacementid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeState, enabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeState, shapemode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeState, solid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeState, dynamic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeState, navflagoverride_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeState, activemodelcrc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeState, modelname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeState, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeState, type_),
  };
  NodeState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NodeState_descriptor_,
      NodeState::default_instance_,
      NodeState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeState, _unknown_fields_),
      -1,
      NodeState_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeState, _oneof_case_[0]),
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NodeState));
  NavigationMesh_descriptor_ = file->message_type(8);
  static const int NavigationMesh_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavigationMesh, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavigationMesh, navmeshparams_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavigationMesh, exclusionzone_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavigationMesh, offmeshconnection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavigationMesh, nodestate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavigationMesh, models_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavigationMesh, tiles_),
  };
  NavigationMesh_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NavigationMesh_descriptor_,
      NavigationMesh::default_instance_,
      NavigationMesh_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavigationMesh, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavigationMesh, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NavigationMesh));
  ShapeMode_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_recast_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Vec3_descriptor_, &Vec3::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AxisAlignedBounds_descriptor_, &AxisAlignedBounds::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NavMeshParams_descriptor_, &NavMeshParams::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Tile_descriptor_, &Tile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OffMeshConnection_descriptor_, &OffMeshConnection::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Material_descriptor_, &Material::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Model_descriptor_, &Model::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Model_TriParms_descriptor_, &Model_TriParms::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NodeState_descriptor_, &NodeState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NavigationMesh_descriptor_, &NavigationMesh::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_recast_2eproto() {
  delete Vec3::default_instance_;
  delete Vec3_reflection_;
  delete AxisAlignedBounds::default_instance_;
  delete AxisAlignedBounds_reflection_;
  delete NavMeshParams::default_instance_;
  delete NavMeshParams_reflection_;
  delete Tile::default_instance_;
  delete Tile_reflection_;
  delete OffMeshConnection::default_instance_;
  delete OffMeshConnection_reflection_;
  delete Material::default_instance_;
  delete Material_reflection_;
  delete Model::default_instance_;
  delete Model_reflection_;
  delete Model_TriParms::default_instance_;
  delete Model_TriParms_reflection_;
  delete NodeState::default_instance_;
  delete NodeState_default_oneof_instance_;
  delete NodeState_reflection_;
  delete NavigationMesh::default_instance_;
  delete NavigationMesh_reflection_;
}

void protobuf_AddDesc_recast_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014recast.proto\022\010RecastIO\"\'\n\004Vec3\022\t\n\001x\030\001 "
    "\001(\002\022\t\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\"O\n\021AxisAligned"
    "Bounds\022\034\n\004mins\030\001 \002(\0132\016.RecastIO.Vec3\022\034\n\004"
    "maxs\030\002 \002(\0132\016.RecastIO.Vec3\"\240\002\n\rNavMeshPa"
    "rams\022\030\n\020agentHeightStand\030\001 \002(\002\022\031\n\021agentH"
    "eightCrouch\030\002 \002(\002\022\023\n\013agentRadius\030\003 \002(\002\022\022"
    "\n\nagentClimb\030\004 \002(\002\022\026\n\016walkSlopeAngle\030\005 \002"
    "(\002\022\020\n\010cellSize\030\006 \002(\002\022\022\n\ncellHeight\030\007 \002(\002"
    "\022\025\n\redgeMaxLength\030\010 \002(\002\022\024\n\014edgeMaxError\030"
    "\t \002(\002\022\020\n\010tileSize\030\n \002(\005\022\030\n\020detailSampleD"
    "ist\030\013 \002(\002\022\032\n\022detailSampleMaxErr\030\014 \002(\002\"8\n"
    "\004Tile\022\030\n\020unCompressedSize\030\001 \002(\005\022\026\n\016compr"
    "essedData\030\002 \002(\014\"\271\001\n\021OffMeshConnection\022 \n"
    "\010entryPos\030\001 \002(\0132\016.RecastIO.Vec3\022\037\n\007exitP"
    "os\030\002 \002(\0132\016.RecastIO.Vec3\022 \n\010vertices\030\003 \003"
    "(\0132\016.RecastIO.Vec3\022\016\n\006radius\030\004 \002(\002\022\021\n\tar"
    "eaflags\030\005 \002(\004\022\034\n\rbiDirectional\030\006 \001(\010:\005fa"
    "lse\"@\n\010Material\022\014\n\004name\030\001 \002(\t\022\020\n\010content"
    "s\030\002 \001(\r\022\024\n\014surfaceflags\030\003 \001(\r\"\233\001\n\005Model\022"
    "\014\n\004name\030\001 \002(\t\022\020\n\010modelcrc\030\002 \002(\r\022\023\n\013numMe"
    "shTris\030\003 \002(\r\022+\n\ttriangles\030\004 \003(\0132\030.Recast"
    "IO.Model.TriParms\0320\n\010TriParms\022\013\n\003tri\030\001 \002"
    "(\r\022\027\n\017surfaceOverride\030\002 \001(\r\"\261\002\n\tNodeStat"
    "e\022\024\n\nsubModelId\030\001 \001(\005H\000\022\027\n\rstaticModelId"
    "\030\002 \001(\005H\000\022\030\n\016displacementId\030\003 \001(\005H\000\022\025\n\007en"
    "abled\030\005 \001(\010:\004true\0227\n\tshapemode\030\006 \001(\0162\023.R"
    "ecastIO.ShapeMode:\017SHAPE_TRIANGLES\022\023\n\005so"
    "lid\030\007 \001(\010:\004true\022\026\n\007dynamic\030\010 \001(\010:\005false\022"
    "\032\n\017navFlagOverride\030\t \001(\004:\0010\022\031\n\016activeMod"
    "elCrc\030\n \001(\r:\0010\022\021\n\tmodelname\030\013 \001(\t\022\014\n\004nam"
    "e\030\014 \001(\tB\006\n\004type\"\245\002\n\016NavigationMesh\022\017\n\007ve"
    "rsion\030\001 \002(\005\022.\n\rnavMeshParams\030\002 \002(\0132\027.Rec"
    "astIO.NavMeshParams\0222\n\rexclusionZone\030\003 \003"
    "(\0132\033.RecastIO.AxisAlignedBounds\0226\n\021offMe"
    "shConnection\030\004 \003(\0132\033.RecastIO.OffMeshCon"
    "nection\022&\n\tnodeState\030\005 \003(\0132\023.RecastIO.No"
    "deState\022\037\n\006models\030\006 \003(\0132\017.RecastIO.Model"
    "\022\035\n\005tiles\030d \003(\0132\016.RecastIO.Tile*/\n\tShape"
    "Mode\022\023\n\017SHAPE_TRIANGLES\020\000\022\r\n\tSHAPE_OBB\020\001", 1560);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "recast.proto", &protobuf_RegisterTypes);
  Vec3::default_instance_ = new Vec3();
  AxisAlignedBounds::default_instance_ = new AxisAlignedBounds();
  NavMeshParams::default_instance_ = new NavMeshParams();
  Tile::default_instance_ = new Tile();
  OffMeshConnection::default_instance_ = new OffMeshConnection();
  Material::default_instance_ = new Material();
  Model::default_instance_ = new Model();
  Model_TriParms::default_instance_ = new Model_TriParms();
  NodeState::default_instance_ = new NodeState();
  NodeState_default_oneof_instance_ = new NodeStateOneofInstance;
  NavigationMesh::default_instance_ = new NavigationMesh();
  Vec3::default_instance_->InitAsDefaultInstance();
  AxisAlignedBounds::default_instance_->InitAsDefaultInstance();
  NavMeshParams::default_instance_->InitAsDefaultInstance();
  Tile::default_instance_->InitAsDefaultInstance();
  OffMeshConnection::default_instance_->InitAsDefaultInstance();
  Material::default_instance_->InitAsDefaultInstance();
  Model::default_instance_->InitAsDefaultInstance();
  Model_TriParms::default_instance_->InitAsDefaultInstance();
  NodeState::default_instance_->InitAsDefaultInstance();
  NavigationMesh::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_recast_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_recast_2eproto {
  StaticDescriptorInitializer_recast_2eproto() {
    protobuf_AddDesc_recast_2eproto();
  }
} static_descriptor_initializer_recast_2eproto_;
const ::google::protobuf::EnumDescriptor* ShapeMode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShapeMode_descriptor_;
}
bool ShapeMode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Vec3::kXFieldNumber;
const int Vec3::kYFieldNumber;
const int Vec3::kZFieldNumber;
#endif  // !_MSC_VER

Vec3::Vec3()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RecastIO.Vec3)
}

void Vec3::InitAsDefaultInstance() {
}

Vec3::Vec3(const Vec3& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RecastIO.Vec3)
}

void Vec3::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vec3::~Vec3() {
  // @@protoc_insertion_point(destructor:RecastIO.Vec3)
  SharedDtor();
}

void Vec3::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Vec3::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Vec3::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Vec3_descriptor_;
}

const Vec3& Vec3::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_recast_2eproto();
  return *default_instance_;
}

Vec3* Vec3::default_instance_ = NULL;

Vec3* Vec3::New() const {
  return new Vec3;
}

void Vec3::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Vec3*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, z_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Vec3::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RecastIO.Vec3)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // optional float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // optional float z = 3;
      case 3: {
        if (tag == 29) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RecastIO.Vec3)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RecastIO.Vec3)
  return false;
#undef DO_
}

void Vec3::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RecastIO.Vec3)
  // optional float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // optional float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // optional float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RecastIO.Vec3)
}

::google::protobuf::uint8* Vec3::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RecastIO.Vec3)
  // optional float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // optional float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // optional float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RecastIO.Vec3)
  return target;
}

int Vec3::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // optional float z = 3;
    if (has_z()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vec3::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Vec3* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Vec3*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Vec3::MergeFrom(const Vec3& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Vec3::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vec3::CopyFrom(const Vec3& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vec3::IsInitialized() const {

  return true;
}

void Vec3::Swap(Vec3* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Vec3::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Vec3_descriptor_;
  metadata.reflection = Vec3_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AxisAlignedBounds::kMinsFieldNumber;
const int AxisAlignedBounds::kMaxsFieldNumber;
#endif  // !_MSC_VER

AxisAlignedBounds::AxisAlignedBounds()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RecastIO.AxisAlignedBounds)
}

void AxisAlignedBounds::InitAsDefaultInstance() {
  mins_ = const_cast< ::RecastIO::Vec3*>(&::RecastIO::Vec3::default_instance());
  maxs_ = const_cast< ::RecastIO::Vec3*>(&::RecastIO::Vec3::default_instance());
}

AxisAlignedBounds::AxisAlignedBounds(const AxisAlignedBounds& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RecastIO.AxisAlignedBounds)
}

void AxisAlignedBounds::SharedCtor() {
  _cached_size_ = 0;
  mins_ = NULL;
  maxs_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AxisAlignedBounds::~AxisAlignedBounds() {
  // @@protoc_insertion_point(destructor:RecastIO.AxisAlignedBounds)
  SharedDtor();
}

void AxisAlignedBounds::SharedDtor() {
  if (this != default_instance_) {
    delete mins_;
    delete maxs_;
  }
}

void AxisAlignedBounds::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AxisAlignedBounds::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AxisAlignedBounds_descriptor_;
}

const AxisAlignedBounds& AxisAlignedBounds::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_recast_2eproto();
  return *default_instance_;
}

AxisAlignedBounds* AxisAlignedBounds::default_instance_ = NULL;

AxisAlignedBounds* AxisAlignedBounds::New() const {
  return new AxisAlignedBounds;
}

void AxisAlignedBounds::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_mins()) {
      if (mins_ != NULL) mins_->::RecastIO::Vec3::Clear();
    }
    if (has_maxs()) {
      if (maxs_ != NULL) maxs_->::RecastIO::Vec3::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AxisAlignedBounds::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RecastIO.AxisAlignedBounds)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .RecastIO.Vec3 mins = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mins()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_maxs;
        break;
      }

      // required .RecastIO.Vec3 maxs = 2;
      case 2: {
        if (tag == 18) {
         parse_maxs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_maxs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RecastIO.AxisAlignedBounds)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RecastIO.AxisAlignedBounds)
  return false;
#undef DO_
}

void AxisAlignedBounds::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RecastIO.AxisAlignedBounds)
  // required .RecastIO.Vec3 mins = 1;
  if (has_mins()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->mins(), output);
  }

  // required .RecastIO.Vec3 maxs = 2;
  if (has_maxs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->maxs(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RecastIO.AxisAlignedBounds)
}

::google::protobuf::uint8* AxisAlignedBounds::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RecastIO.AxisAlignedBounds)
  // required .RecastIO.Vec3 mins = 1;
  if (has_mins()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->mins(), target);
  }

  // required .RecastIO.Vec3 maxs = 2;
  if (has_maxs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->maxs(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RecastIO.AxisAlignedBounds)
  return target;
}

int AxisAlignedBounds::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .RecastIO.Vec3 mins = 1;
    if (has_mins()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mins());
    }

    // required .RecastIO.Vec3 maxs = 2;
    if (has_maxs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->maxs());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AxisAlignedBounds::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AxisAlignedBounds* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AxisAlignedBounds*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AxisAlignedBounds::MergeFrom(const AxisAlignedBounds& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mins()) {
      mutable_mins()->::RecastIO::Vec3::MergeFrom(from.mins());
    }
    if (from.has_maxs()) {
      mutable_maxs()->::RecastIO::Vec3::MergeFrom(from.maxs());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AxisAlignedBounds::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AxisAlignedBounds::CopyFrom(const AxisAlignedBounds& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AxisAlignedBounds::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void AxisAlignedBounds::Swap(AxisAlignedBounds* other) {
  if (other != this) {
    std::swap(mins_, other->mins_);
    std::swap(maxs_, other->maxs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AxisAlignedBounds::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AxisAlignedBounds_descriptor_;
  metadata.reflection = AxisAlignedBounds_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NavMeshParams::kAgentHeightStandFieldNumber;
const int NavMeshParams::kAgentHeightCrouchFieldNumber;
const int NavMeshParams::kAgentRadiusFieldNumber;
const int NavMeshParams::kAgentClimbFieldNumber;
const int NavMeshParams::kWalkSlopeAngleFieldNumber;
const int NavMeshParams::kCellSizeFieldNumber;
const int NavMeshParams::kCellHeightFieldNumber;
const int NavMeshParams::kEdgeMaxLengthFieldNumber;
const int NavMeshParams::kEdgeMaxErrorFieldNumber;
const int NavMeshParams::kTileSizeFieldNumber;
const int NavMeshParams::kDetailSampleDistFieldNumber;
const int NavMeshParams::kDetailSampleMaxErrFieldNumber;
#endif  // !_MSC_VER

NavMeshParams::NavMeshParams()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RecastIO.NavMeshParams)
}

void NavMeshParams::InitAsDefaultInstance() {
}

NavMeshParams::NavMeshParams(const NavMeshParams& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RecastIO.NavMeshParams)
}

void NavMeshParams::SharedCtor() {
  _cached_size_ = 0;
  agentheightstand_ = 0;
  agentheightcrouch_ = 0;
  agentradius_ = 0;
  agentclimb_ = 0;
  walkslopeangle_ = 0;
  cellsize_ = 0;
  cellheight_ = 0;
  edgemaxlength_ = 0;
  edgemaxerror_ = 0;
  tilesize_ = 0;
  detailsampledist_ = 0;
  detailsamplemaxerr_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NavMeshParams::~NavMeshParams() {
  // @@protoc_insertion_point(destructor:RecastIO.NavMeshParams)
  SharedDtor();
}

void NavMeshParams::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NavMeshParams::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NavMeshParams::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NavMeshParams_descriptor_;
}

const NavMeshParams& NavMeshParams::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_recast_2eproto();
  return *default_instance_;
}

NavMeshParams* NavMeshParams::default_instance_ = NULL;

NavMeshParams* NavMeshParams::New() const {
  return new NavMeshParams;
}

void NavMeshParams::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<NavMeshParams*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(agentheightstand_, edgemaxlength_);
  }
  ZR_(edgemaxerror_, detailsamplemaxerr_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NavMeshParams::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RecastIO.NavMeshParams)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float agentHeightStand = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &agentheightstand_)));
          set_has_agentheightstand();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_agentHeightCrouch;
        break;
      }

      // required float agentHeightCrouch = 2;
      case 2: {
        if (tag == 21) {
         parse_agentHeightCrouch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &agentheightcrouch_)));
          set_has_agentheightcrouch();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_agentRadius;
        break;
      }

      // required float agentRadius = 3;
      case 3: {
        if (tag == 29) {
         parse_agentRadius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &agentradius_)));
          set_has_agentradius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_agentClimb;
        break;
      }

      // required float agentClimb = 4;
      case 4: {
        if (tag == 37) {
         parse_agentClimb:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &agentclimb_)));
          set_has_agentclimb();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_walkSlopeAngle;
        break;
      }

      // required float walkSlopeAngle = 5;
      case 5: {
        if (tag == 45) {
         parse_walkSlopeAngle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &walkslopeangle_)));
          set_has_walkslopeangle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_cellSize;
        break;
      }

      // required float cellSize = 6;
      case 6: {
        if (tag == 53) {
         parse_cellSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cellsize_)));
          set_has_cellsize();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_cellHeight;
        break;
      }

      // required float cellHeight = 7;
      case 7: {
        if (tag == 61) {
         parse_cellHeight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cellheight_)));
          set_has_cellheight();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_edgeMaxLength;
        break;
      }

      // required float edgeMaxLength = 8;
      case 8: {
        if (tag == 69) {
         parse_edgeMaxLength:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &edgemaxlength_)));
          set_has_edgemaxlength();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_edgeMaxError;
        break;
      }

      // required float edgeMaxError = 9;
      case 9: {
        if (tag == 77) {
         parse_edgeMaxError:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &edgemaxerror_)));
          set_has_edgemaxerror();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_tileSize;
        break;
      }

      // required int32 tileSize = 10;
      case 10: {
        if (tag == 80) {
         parse_tileSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tilesize_)));
          set_has_tilesize();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(93)) goto parse_detailSampleDist;
        break;
      }

      // required float detailSampleDist = 11;
      case 11: {
        if (tag == 93) {
         parse_detailSampleDist:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &detailsampledist_)));
          set_has_detailsampledist();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(101)) goto parse_detailSampleMaxErr;
        break;
      }

      // required float detailSampleMaxErr = 12;
      case 12: {
        if (tag == 101) {
         parse_detailSampleMaxErr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &detailsamplemaxerr_)));
          set_has_detailsamplemaxerr();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RecastIO.NavMeshParams)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RecastIO.NavMeshParams)
  return false;
#undef DO_
}

void NavMeshParams::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RecastIO.NavMeshParams)
  // required float agentHeightStand = 1;
  if (has_agentheightstand()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->agentheightstand(), output);
  }

  // required float agentHeightCrouch = 2;
  if (has_agentheightcrouch()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->agentheightcrouch(), output);
  }

  // required float agentRadius = 3;
  if (has_agentradius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->agentradius(), output);
  }

  // required float agentClimb = 4;
  if (has_agentclimb()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->agentclimb(), output);
  }

  // required float walkSlopeAngle = 5;
  if (has_walkslopeangle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->walkslopeangle(), output);
  }

  // required float cellSize = 6;
  if (has_cellsize()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->cellsize(), output);
  }

  // required float cellHeight = 7;
  if (has_cellheight()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->cellheight(), output);
  }

  // required float edgeMaxLength = 8;
  if (has_edgemaxlength()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->edgemaxlength(), output);
  }

  // required float edgeMaxError = 9;
  if (has_edgemaxerror()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->edgemaxerror(), output);
  }

  // required int32 tileSize = 10;
  if (has_tilesize()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->tilesize(), output);
  }

  // required float detailSampleDist = 11;
  if (has_detailsampledist()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->detailsampledist(), output);
  }

  // required float detailSampleMaxErr = 12;
  if (has_detailsamplemaxerr()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->detailsamplemaxerr(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RecastIO.NavMeshParams)
}

::google::protobuf::uint8* NavMeshParams::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RecastIO.NavMeshParams)
  // required float agentHeightStand = 1;
  if (has_agentheightstand()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->agentheightstand(), target);
  }

  // required float agentHeightCrouch = 2;
  if (has_agentheightcrouch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->agentheightcrouch(), target);
  }

  // required float agentRadius = 3;
  if (has_agentradius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->agentradius(), target);
  }

  // required float agentClimb = 4;
  if (has_agentclimb()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->agentclimb(), target);
  }

  // required float walkSlopeAngle = 5;
  if (has_walkslopeangle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->walkslopeangle(), target);
  }

  // required float cellSize = 6;
  if (has_cellsize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->cellsize(), target);
  }

  // required float cellHeight = 7;
  if (has_cellheight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->cellheight(), target);
  }

  // required float edgeMaxLength = 8;
  if (has_edgemaxlength()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->edgemaxlength(), target);
  }

  // required float edgeMaxError = 9;
  if (has_edgemaxerror()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->edgemaxerror(), target);
  }

  // required int32 tileSize = 10;
  if (has_tilesize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->tilesize(), target);
  }

  // required float detailSampleDist = 11;
  if (has_detailsampledist()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->detailsampledist(), target);
  }

  // required float detailSampleMaxErr = 12;
  if (has_detailsamplemaxerr()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->detailsamplemaxerr(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RecastIO.NavMeshParams)
  return target;
}

int NavMeshParams::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float agentHeightStand = 1;
    if (has_agentheightstand()) {
      total_size += 1 + 4;
    }

    // required float agentHeightCrouch = 2;
    if (has_agentheightcrouch()) {
      total_size += 1 + 4;
    }

    // required float agentRadius = 3;
    if (has_agentradius()) {
      total_size += 1 + 4;
    }

    // required float agentClimb = 4;
    if (has_agentclimb()) {
      total_size += 1 + 4;
    }

    // required float walkSlopeAngle = 5;
    if (has_walkslopeangle()) {
      total_size += 1 + 4;
    }

    // required float cellSize = 6;
    if (has_cellsize()) {
      total_size += 1 + 4;
    }

    // required float cellHeight = 7;
    if (has_cellheight()) {
      total_size += 1 + 4;
    }

    // required float edgeMaxLength = 8;
    if (has_edgemaxlength()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required float edgeMaxError = 9;
    if (has_edgemaxerror()) {
      total_size += 1 + 4;
    }

    // required int32 tileSize = 10;
    if (has_tilesize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tilesize());
    }

    // required float detailSampleDist = 11;
    if (has_detailsampledist()) {
      total_size += 1 + 4;
    }

    // required float detailSampleMaxErr = 12;
    if (has_detailsamplemaxerr()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NavMeshParams::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NavMeshParams* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NavMeshParams*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NavMeshParams::MergeFrom(const NavMeshParams& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agentheightstand()) {
      set_agentheightstand(from.agentheightstand());
    }
    if (from.has_agentheightcrouch()) {
      set_agentheightcrouch(from.agentheightcrouch());
    }
    if (from.has_agentradius()) {
      set_agentradius(from.agentradius());
    }
    if (from.has_agentclimb()) {
      set_agentclimb(from.agentclimb());
    }
    if (from.has_walkslopeangle()) {
      set_walkslopeangle(from.walkslopeangle());
    }
    if (from.has_cellsize()) {
      set_cellsize(from.cellsize());
    }
    if (from.has_cellheight()) {
      set_cellheight(from.cellheight());
    }
    if (from.has_edgemaxlength()) {
      set_edgemaxlength(from.edgemaxlength());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_edgemaxerror()) {
      set_edgemaxerror(from.edgemaxerror());
    }
    if (from.has_tilesize()) {
      set_tilesize(from.tilesize());
    }
    if (from.has_detailsampledist()) {
      set_detailsampledist(from.detailsampledist());
    }
    if (from.has_detailsamplemaxerr()) {
      set_detailsamplemaxerr(from.detailsamplemaxerr());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NavMeshParams::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NavMeshParams::CopyFrom(const NavMeshParams& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NavMeshParams::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000fff) != 0x00000fff) return false;

  return true;
}

void NavMeshParams::Swap(NavMeshParams* other) {
  if (other != this) {
    std::swap(agentheightstand_, other->agentheightstand_);
    std::swap(agentheightcrouch_, other->agentheightcrouch_);
    std::swap(agentradius_, other->agentradius_);
    std::swap(agentclimb_, other->agentclimb_);
    std::swap(walkslopeangle_, other->walkslopeangle_);
    std::swap(cellsize_, other->cellsize_);
    std::swap(cellheight_, other->cellheight_);
    std::swap(edgemaxlength_, other->edgemaxlength_);
    std::swap(edgemaxerror_, other->edgemaxerror_);
    std::swap(tilesize_, other->tilesize_);
    std::swap(detailsampledist_, other->detailsampledist_);
    std::swap(detailsamplemaxerr_, other->detailsamplemaxerr_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NavMeshParams::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NavMeshParams_descriptor_;
  metadata.reflection = NavMeshParams_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Tile::kUnCompressedSizeFieldNumber;
const int Tile::kCompressedDataFieldNumber;
#endif  // !_MSC_VER

Tile::Tile()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RecastIO.Tile)
}

void Tile::InitAsDefaultInstance() {
}

Tile::Tile(const Tile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RecastIO.Tile)
}

void Tile::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uncompressedsize_ = 0;
  compresseddata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Tile::~Tile() {
  // @@protoc_insertion_point(destructor:RecastIO.Tile)
  SharedDtor();
}

void Tile::SharedDtor() {
  if (compresseddata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete compresseddata_;
  }
  if (this != default_instance_) {
  }
}

void Tile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Tile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Tile_descriptor_;
}

const Tile& Tile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_recast_2eproto();
  return *default_instance_;
}

Tile* Tile::default_instance_ = NULL;

Tile* Tile::New() const {
  return new Tile;
}

void Tile::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    uncompressedsize_ = 0;
    if (has_compresseddata()) {
      if (compresseddata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        compresseddata_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Tile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RecastIO.Tile)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 unCompressedSize = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uncompressedsize_)));
          set_has_uncompressedsize();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_compressedData;
        break;
      }

      // required bytes compressedData = 2;
      case 2: {
        if (tag == 18) {
         parse_compressedData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_compresseddata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RecastIO.Tile)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RecastIO.Tile)
  return false;
#undef DO_
}

void Tile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RecastIO.Tile)
  // required int32 unCompressedSize = 1;
  if (has_uncompressedsize()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uncompressedsize(), output);
  }

  // required bytes compressedData = 2;
  if (has_compresseddata()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->compresseddata(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RecastIO.Tile)
}

::google::protobuf::uint8* Tile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RecastIO.Tile)
  // required int32 unCompressedSize = 1;
  if (has_uncompressedsize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->uncompressedsize(), target);
  }

  // required bytes compressedData = 2;
  if (has_compresseddata()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->compresseddata(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RecastIO.Tile)
  return target;
}

int Tile::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 unCompressedSize = 1;
    if (has_uncompressedsize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uncompressedsize());
    }

    // required bytes compressedData = 2;
    if (has_compresseddata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->compresseddata());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Tile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Tile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Tile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Tile::MergeFrom(const Tile& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uncompressedsize()) {
      set_uncompressedsize(from.uncompressedsize());
    }
    if (from.has_compresseddata()) {
      set_compresseddata(from.compresseddata());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Tile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Tile::CopyFrom(const Tile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tile::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Tile::Swap(Tile* other) {
  if (other != this) {
    std::swap(uncompressedsize_, other->uncompressedsize_);
    std::swap(compresseddata_, other->compresseddata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Tile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Tile_descriptor_;
  metadata.reflection = Tile_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OffMeshConnection::kEntryPosFieldNumber;
const int OffMeshConnection::kExitPosFieldNumber;
const int OffMeshConnection::kVerticesFieldNumber;
const int OffMeshConnection::kRadiusFieldNumber;
const int OffMeshConnection::kAreaflagsFieldNumber;
const int OffMeshConnection::kBiDirectionalFieldNumber;
#endif  // !_MSC_VER

OffMeshConnection::OffMeshConnection()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RecastIO.OffMeshConnection)
}

void OffMeshConnection::InitAsDefaultInstance() {
  entrypos_ = const_cast< ::RecastIO::Vec3*>(&::RecastIO::Vec3::default_instance());
  exitpos_ = const_cast< ::RecastIO::Vec3*>(&::RecastIO::Vec3::default_instance());
}

OffMeshConnection::OffMeshConnection(const OffMeshConnection& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RecastIO.OffMeshConnection)
}

void OffMeshConnection::SharedCtor() {
  _cached_size_ = 0;
  entrypos_ = NULL;
  exitpos_ = NULL;
  radius_ = 0;
  areaflags_ = GOOGLE_ULONGLONG(0);
  bidirectional_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OffMeshConnection::~OffMeshConnection() {
  // @@protoc_insertion_point(destructor:RecastIO.OffMeshConnection)
  SharedDtor();
}

void OffMeshConnection::SharedDtor() {
  if (this != default_instance_) {
    delete entrypos_;
    delete exitpos_;
  }
}

void OffMeshConnection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OffMeshConnection::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OffMeshConnection_descriptor_;
}

const OffMeshConnection& OffMeshConnection::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_recast_2eproto();
  return *default_instance_;
}

OffMeshConnection* OffMeshConnection::default_instance_ = NULL;

OffMeshConnection* OffMeshConnection::New() const {
  return new OffMeshConnection;
}

void OffMeshConnection::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<OffMeshConnection*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 59) {
    ZR_(areaflags_, bidirectional_);
    if (has_entrypos()) {
      if (entrypos_ != NULL) entrypos_->::RecastIO::Vec3::Clear();
    }
    if (has_exitpos()) {
      if (exitpos_ != NULL) exitpos_->::RecastIO::Vec3::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  vertices_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OffMeshConnection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RecastIO.OffMeshConnection)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .RecastIO.Vec3 entryPos = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_entrypos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_exitPos;
        break;
      }

      // required .RecastIO.Vec3 exitPos = 2;
      case 2: {
        if (tag == 18) {
         parse_exitPos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exitpos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_vertices;
        break;
      }

      // repeated .RecastIO.Vec3 vertices = 3;
      case 3: {
        if (tag == 26) {
         parse_vertices:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_vertices()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_vertices;
        if (input->ExpectTag(37)) goto parse_radius;
        break;
      }

      // required float radius = 4;
      case 4: {
        if (tag == 37) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_areaflags;
        break;
      }

      // required uint64 areaflags = 5;
      case 5: {
        if (tag == 40) {
         parse_areaflags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &areaflags_)));
          set_has_areaflags();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_biDirectional;
        break;
      }

      // optional bool biDirectional = 6 [default = false];
      case 6: {
        if (tag == 48) {
         parse_biDirectional:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bidirectional_)));
          set_has_bidirectional();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RecastIO.OffMeshConnection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RecastIO.OffMeshConnection)
  return false;
#undef DO_
}

void OffMeshConnection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RecastIO.OffMeshConnection)
  // required .RecastIO.Vec3 entryPos = 1;
  if (has_entrypos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->entrypos(), output);
  }

  // required .RecastIO.Vec3 exitPos = 2;
  if (has_exitpos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->exitpos(), output);
  }

  // repeated .RecastIO.Vec3 vertices = 3;
  for (int i = 0; i < this->vertices_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->vertices(i), output);
  }

  // required float radius = 4;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->radius(), output);
  }

  // required uint64 areaflags = 5;
  if (has_areaflags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->areaflags(), output);
  }

  // optional bool biDirectional = 6 [default = false];
  if (has_bidirectional()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->bidirectional(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RecastIO.OffMeshConnection)
}

::google::protobuf::uint8* OffMeshConnection::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RecastIO.OffMeshConnection)
  // required .RecastIO.Vec3 entryPos = 1;
  if (has_entrypos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->entrypos(), target);
  }

  // required .RecastIO.Vec3 exitPos = 2;
  if (has_exitpos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->exitpos(), target);
  }

  // repeated .RecastIO.Vec3 vertices = 3;
  for (int i = 0; i < this->vertices_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->vertices(i), target);
  }

  // required float radius = 4;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->radius(), target);
  }

  // required uint64 areaflags = 5;
  if (has_areaflags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->areaflags(), target);
  }

  // optional bool biDirectional = 6 [default = false];
  if (has_bidirectional()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->bidirectional(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RecastIO.OffMeshConnection)
  return target;
}

int OffMeshConnection::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .RecastIO.Vec3 entryPos = 1;
    if (has_entrypos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->entrypos());
    }

    // required .RecastIO.Vec3 exitPos = 2;
    if (has_exitpos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exitpos());
    }

    // required float radius = 4;
    if (has_radius()) {
      total_size += 1 + 4;
    }

    // required uint64 areaflags = 5;
    if (has_areaflags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->areaflags());
    }

    // optional bool biDirectional = 6 [default = false];
    if (has_bidirectional()) {
      total_size += 1 + 1;
    }

  }
  // repeated .RecastIO.Vec3 vertices = 3;
  total_size += 1 * this->vertices_size();
  for (int i = 0; i < this->vertices_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->vertices(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OffMeshConnection::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OffMeshConnection* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OffMeshConnection*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OffMeshConnection::MergeFrom(const OffMeshConnection& from) {
  GOOGLE_CHECK_NE(&from, this);
  vertices_.MergeFrom(from.vertices_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_entrypos()) {
      mutable_entrypos()->::RecastIO::Vec3::MergeFrom(from.entrypos());
    }
    if (from.has_exitpos()) {
      mutable_exitpos()->::RecastIO::Vec3::MergeFrom(from.exitpos());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
    if (from.has_areaflags()) {
      set_areaflags(from.areaflags());
    }
    if (from.has_bidirectional()) {
      set_bidirectional(from.bidirectional());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OffMeshConnection::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OffMeshConnection::CopyFrom(const OffMeshConnection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OffMeshConnection::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001b) != 0x0000001b) return false;

  return true;
}

void OffMeshConnection::Swap(OffMeshConnection* other) {
  if (other != this) {
    std::swap(entrypos_, other->entrypos_);
    std::swap(exitpos_, other->exitpos_);
    vertices_.Swap(&other->vertices_);
    std::swap(radius_, other->radius_);
    std::swap(areaflags_, other->areaflags_);
    std::swap(bidirectional_, other->bidirectional_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OffMeshConnection::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OffMeshConnection_descriptor_;
  metadata.reflection = OffMeshConnection_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Material::kNameFieldNumber;
const int Material::kContentsFieldNumber;
const int Material::kSurfaceflagsFieldNumber;
#endif  // !_MSC_VER

Material::Material()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RecastIO.Material)
}

void Material::InitAsDefaultInstance() {
}

Material::Material(const Material& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RecastIO.Material)
}

void Material::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  contents_ = 0u;
  surfaceflags_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Material::~Material() {
  // @@protoc_insertion_point(destructor:RecastIO.Material)
  SharedDtor();
}

void Material::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Material::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Material::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Material_descriptor_;
}

const Material& Material::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_recast_2eproto();
  return *default_instance_;
}

Material* Material::default_instance_ = NULL;

Material* Material::New() const {
  return new Material;
}

void Material::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Material*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(contents_, surfaceflags_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Material::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RecastIO.Material)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_contents;
        break;
      }

      // optional uint32 contents = 2;
      case 2: {
        if (tag == 16) {
         parse_contents:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &contents_)));
          set_has_contents();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_surfaceflags;
        break;
      }

      // optional uint32 surfaceflags = 3;
      case 3: {
        if (tag == 24) {
         parse_surfaceflags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &surfaceflags_)));
          set_has_surfaceflags();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RecastIO.Material)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RecastIO.Material)
  return false;
#undef DO_
}

void Material::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RecastIO.Material)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional uint32 contents = 2;
  if (has_contents()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->contents(), output);
  }

  // optional uint32 surfaceflags = 3;
  if (has_surfaceflags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->surfaceflags(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RecastIO.Material)
}

::google::protobuf::uint8* Material::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RecastIO.Material)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional uint32 contents = 2;
  if (has_contents()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->contents(), target);
  }

  // optional uint32 surfaceflags = 3;
  if (has_surfaceflags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->surfaceflags(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RecastIO.Material)
  return target;
}

int Material::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint32 contents = 2;
    if (has_contents()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->contents());
    }

    // optional uint32 surfaceflags = 3;
    if (has_surfaceflags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->surfaceflags());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Material::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Material* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Material*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Material::MergeFrom(const Material& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_contents()) {
      set_contents(from.contents());
    }
    if (from.has_surfaceflags()) {
      set_surfaceflags(from.surfaceflags());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Material::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Material::CopyFrom(const Material& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Material::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Material::Swap(Material* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(contents_, other->contents_);
    std::swap(surfaceflags_, other->surfaceflags_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Material::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Material_descriptor_;
  metadata.reflection = Material_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Model_TriParms::kTriFieldNumber;
const int Model_TriParms::kSurfaceOverrideFieldNumber;
#endif  // !_MSC_VER

Model_TriParms::Model_TriParms()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RecastIO.Model.TriParms)
}

void Model_TriParms::InitAsDefaultInstance() {
}

Model_TriParms::Model_TriParms(const Model_TriParms& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RecastIO.Model.TriParms)
}

void Model_TriParms::SharedCtor() {
  _cached_size_ = 0;
  tri_ = 0u;
  surfaceoverride_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Model_TriParms::~Model_TriParms() {
  // @@protoc_insertion_point(destructor:RecastIO.Model.TriParms)
  SharedDtor();
}

void Model_TriParms::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Model_TriParms::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Model_TriParms::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Model_TriParms_descriptor_;
}

const Model_TriParms& Model_TriParms::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_recast_2eproto();
  return *default_instance_;
}

Model_TriParms* Model_TriParms::default_instance_ = NULL;

Model_TriParms* Model_TriParms::New() const {
  return new Model_TriParms;
}

void Model_TriParms::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Model_TriParms*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(tri_, surfaceoverride_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Model_TriParms::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RecastIO.Model.TriParms)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 tri = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tri_)));
          set_has_tri();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_surfaceOverride;
        break;
      }

      // optional uint32 surfaceOverride = 2;
      case 2: {
        if (tag == 16) {
         parse_surfaceOverride:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &surfaceoverride_)));
          set_has_surfaceoverride();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RecastIO.Model.TriParms)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RecastIO.Model.TriParms)
  return false;
#undef DO_
}

void Model_TriParms::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RecastIO.Model.TriParms)
  // required uint32 tri = 1;
  if (has_tri()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->tri(), output);
  }

  // optional uint32 surfaceOverride = 2;
  if (has_surfaceoverride()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->surfaceoverride(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RecastIO.Model.TriParms)
}

::google::protobuf::uint8* Model_TriParms::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RecastIO.Model.TriParms)
  // required uint32 tri = 1;
  if (has_tri()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->tri(), target);
  }

  // optional uint32 surfaceOverride = 2;
  if (has_surfaceoverride()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->surfaceoverride(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RecastIO.Model.TriParms)
  return target;
}

int Model_TriParms::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 tri = 1;
    if (has_tri()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tri());
    }

    // optional uint32 surfaceOverride = 2;
    if (has_surfaceoverride()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->surfaceoverride());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Model_TriParms::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Model_TriParms* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Model_TriParms*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Model_TriParms::MergeFrom(const Model_TriParms& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tri()) {
      set_tri(from.tri());
    }
    if (from.has_surfaceoverride()) {
      set_surfaceoverride(from.surfaceoverride());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Model_TriParms::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Model_TriParms::CopyFrom(const Model_TriParms& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Model_TriParms::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Model_TriParms::Swap(Model_TriParms* other) {
  if (other != this) {
    std::swap(tri_, other->tri_);
    std::swap(surfaceoverride_, other->surfaceoverride_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Model_TriParms::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Model_TriParms_descriptor_;
  metadata.reflection = Model_TriParms_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Model::kNameFieldNumber;
const int Model::kModelcrcFieldNumber;
const int Model::kNumMeshTrisFieldNumber;
const int Model::kTrianglesFieldNumber;
#endif  // !_MSC_VER

Model::Model()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RecastIO.Model)
}

void Model::InitAsDefaultInstance() {
}

Model::Model(const Model& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RecastIO.Model)
}

void Model::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  modelcrc_ = 0u;
  nummeshtris_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Model::~Model() {
  // @@protoc_insertion_point(destructor:RecastIO.Model)
  SharedDtor();
}

void Model::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Model::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Model::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Model_descriptor_;
}

const Model& Model::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_recast_2eproto();
  return *default_instance_;
}

Model* Model::default_instance_ = NULL;

Model* Model::New() const {
  return new Model;
}

void Model::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Model*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(modelcrc_, nummeshtris_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  triangles_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Model::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RecastIO.Model)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_modelcrc;
        break;
      }

      // required uint32 modelcrc = 2;
      case 2: {
        if (tag == 16) {
         parse_modelcrc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &modelcrc_)));
          set_has_modelcrc();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_numMeshTris;
        break;
      }

      // required uint32 numMeshTris = 3;
      case 3: {
        if (tag == 24) {
         parse_numMeshTris:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nummeshtris_)));
          set_has_nummeshtris();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_triangles;
        break;
      }

      // repeated .RecastIO.Model.TriParms triangles = 4;
      case 4: {
        if (tag == 34) {
         parse_triangles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_triangles()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_triangles;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RecastIO.Model)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RecastIO.Model)
  return false;
#undef DO_
}

void Model::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RecastIO.Model)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required uint32 modelcrc = 2;
  if (has_modelcrc()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->modelcrc(), output);
  }

  // required uint32 numMeshTris = 3;
  if (has_nummeshtris()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->nummeshtris(), output);
  }

  // repeated .RecastIO.Model.TriParms triangles = 4;
  for (int i = 0; i < this->triangles_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->triangles(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RecastIO.Model)
}

::google::protobuf::uint8* Model::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RecastIO.Model)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required uint32 modelcrc = 2;
  if (has_modelcrc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->modelcrc(), target);
  }

  // required uint32 numMeshTris = 3;
  if (has_nummeshtris()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->nummeshtris(), target);
  }

  // repeated .RecastIO.Model.TriParms triangles = 4;
  for (int i = 0; i < this->triangles_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->triangles(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RecastIO.Model)
  return target;
}

int Model::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 modelcrc = 2;
    if (has_modelcrc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->modelcrc());
    }

    // required uint32 numMeshTris = 3;
    if (has_nummeshtris()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nummeshtris());
    }

  }
  // repeated .RecastIO.Model.TriParms triangles = 4;
  total_size += 1 * this->triangles_size();
  for (int i = 0; i < this->triangles_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->triangles(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Model::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Model* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Model*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Model::MergeFrom(const Model& from) {
  GOOGLE_CHECK_NE(&from, this);
  triangles_.MergeFrom(from.triangles_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_modelcrc()) {
      set_modelcrc(from.modelcrc());
    }
    if (from.has_nummeshtris()) {
      set_nummeshtris(from.nummeshtris());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Model::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Model::CopyFrom(const Model& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Model::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->triangles())) return false;
  return true;
}

void Model::Swap(Model* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(modelcrc_, other->modelcrc_);
    std::swap(nummeshtris_, other->nummeshtris_);
    triangles_.Swap(&other->triangles_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Model::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Model_descriptor_;
  metadata.reflection = Model_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NodeState::kSubModelIdFieldNumber;
const int NodeState::kStaticModelIdFieldNumber;
const int NodeState::kDisplacementIdFieldNumber;
const int NodeState::kEnabledFieldNumber;
const int NodeState::kShapemodeFieldNumber;
const int NodeState::kSolidFieldNumber;
const int NodeState::kDynamicFieldNumber;
const int NodeState::kNavFlagOverrideFieldNumber;
const int NodeState::kActiveModelCrcFieldNumber;
const int NodeState::kModelnameFieldNumber;
const int NodeState::kNameFieldNumber;
#endif  // !_MSC_VER

NodeState::NodeState()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RecastIO.NodeState)
}

void NodeState::InitAsDefaultInstance() {
  NodeState_default_oneof_instance_->submodelid_ = 0;
  NodeState_default_oneof_instance_->staticmodelid_ = 0;
  NodeState_default_oneof_instance_->displacementid_ = 0;
}

NodeState::NodeState(const NodeState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RecastIO.NodeState)
}

void NodeState::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  enabled_ = true;
  shapemode_ = 0;
  solid_ = true;
  dynamic_ = false;
  navflagoverride_ = GOOGLE_ULONGLONG(0);
  activemodelcrc_ = 0u;
  modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  clear_has_type();
}

NodeState::~NodeState() {
  // @@protoc_insertion_point(destructor:RecastIO.NodeState)
  SharedDtor();
}

void NodeState::SharedDtor() {
  if (modelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modelname_;
  }
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (has_type()) {
    clear_type();
  }
  if (this != default_instance_) {
  }
}

void NodeState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NodeState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NodeState_descriptor_;
}

const NodeState& NodeState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_recast_2eproto();
  return *default_instance_;
}

NodeState* NodeState::default_instance_ = NULL;

NodeState* NodeState::New() const {
  return new NodeState;
}

void NodeState::clear_type() {
  switch(type_case()) {
    case kSubModelId: {
      // No need to clear
      break;
    }
    case kStaticModelId: {
      // No need to clear
      break;
    }
    case kDisplacementId: {
      // No need to clear
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void NodeState::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<NodeState*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 248) {
    ZR_(dynamic_, navflagoverride_);
    enabled_ = true;
    shapemode_ = 0;
    solid_ = true;
  }
  if (_has_bits_[8 / 32] & 1792) {
    activemodelcrc_ = 0u;
    if (has_modelname()) {
      if (modelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        modelname_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  clear_type();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NodeState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RecastIO.NodeState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 subModelId = 1;
      case 1: {
        if (tag == 8) {
          clear_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_.submodelid_)));
          set_has_submodelid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_staticModelId;
        break;
      }

      // optional int32 staticModelId = 2;
      case 2: {
        if (tag == 16) {
         parse_staticModelId:
          clear_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_.staticmodelid_)));
          set_has_staticmodelid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_displacementId;
        break;
      }

      // optional int32 displacementId = 3;
      case 3: {
        if (tag == 24) {
         parse_displacementId:
          clear_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_.displacementid_)));
          set_has_displacementid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_enabled;
        break;
      }

      // optional bool enabled = 5 [default = true];
      case 5: {
        if (tag == 40) {
         parse_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enabled_)));
          set_has_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_shapemode;
        break;
      }

      // optional .RecastIO.ShapeMode shapemode = 6 [default = SHAPE_TRIANGLES];
      case 6: {
        if (tag == 48) {
         parse_shapemode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::RecastIO::ShapeMode_IsValid(value)) {
            set_shapemode(static_cast< ::RecastIO::ShapeMode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_solid;
        break;
      }

      // optional bool solid = 7 [default = true];
      case 7: {
        if (tag == 56) {
         parse_solid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &solid_)));
          set_has_solid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_dynamic;
        break;
      }

      // optional bool dynamic = 8 [default = false];
      case 8: {
        if (tag == 64) {
         parse_dynamic:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &dynamic_)));
          set_has_dynamic();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_navFlagOverride;
        break;
      }

      // optional uint64 navFlagOverride = 9 [default = 0];
      case 9: {
        if (tag == 72) {
         parse_navFlagOverride:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &navflagoverride_)));
          set_has_navflagoverride();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_activeModelCrc;
        break;
      }

      // optional uint32 activeModelCrc = 10 [default = 0];
      case 10: {
        if (tag == 80) {
         parse_activeModelCrc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &activemodelcrc_)));
          set_has_activemodelcrc();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_modelname;
        break;
      }

      // optional string modelname = 11;
      case 11: {
        if (tag == 90) {
         parse_modelname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_modelname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->modelname().data(), this->modelname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "modelname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_name;
        break;
      }

      // optional string name = 12;
      case 12: {
        if (tag == 98) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RecastIO.NodeState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RecastIO.NodeState)
  return false;
#undef DO_
}

void NodeState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RecastIO.NodeState)
  // optional int32 subModelId = 1;
  if (has_submodelid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->submodelid(), output);
  }

  // optional int32 staticModelId = 2;
  if (has_staticmodelid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->staticmodelid(), output);
  }

  // optional int32 displacementId = 3;
  if (has_displacementid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->displacementid(), output);
  }

  // optional bool enabled = 5 [default = true];
  if (has_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->enabled(), output);
  }

  // optional .RecastIO.ShapeMode shapemode = 6 [default = SHAPE_TRIANGLES];
  if (has_shapemode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->shapemode(), output);
  }

  // optional bool solid = 7 [default = true];
  if (has_solid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->solid(), output);
  }

  // optional bool dynamic = 8 [default = false];
  if (has_dynamic()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->dynamic(), output);
  }

  // optional uint64 navFlagOverride = 9 [default = 0];
  if (has_navflagoverride()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->navflagoverride(), output);
  }

  // optional uint32 activeModelCrc = 10 [default = 0];
  if (has_activemodelcrc()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->activemodelcrc(), output);
  }

  // optional string modelname = 11;
  if (has_modelname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->modelname().data(), this->modelname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "modelname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->modelname(), output);
  }

  // optional string name = 12;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RecastIO.NodeState)
}

::google::protobuf::uint8* NodeState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RecastIO.NodeState)
  // optional int32 subModelId = 1;
  if (has_submodelid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->submodelid(), target);
  }

  // optional int32 staticModelId = 2;
  if (has_staticmodelid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->staticmodelid(), target);
  }

  // optional int32 displacementId = 3;
  if (has_displacementid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->displacementid(), target);
  }

  // optional bool enabled = 5 [default = true];
  if (has_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->enabled(), target);
  }

  // optional .RecastIO.ShapeMode shapemode = 6 [default = SHAPE_TRIANGLES];
  if (has_shapemode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->shapemode(), target);
  }

  // optional bool solid = 7 [default = true];
  if (has_solid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->solid(), target);
  }

  // optional bool dynamic = 8 [default = false];
  if (has_dynamic()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->dynamic(), target);
  }

  // optional uint64 navFlagOverride = 9 [default = 0];
  if (has_navflagoverride()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(9, this->navflagoverride(), target);
  }

  // optional uint32 activeModelCrc = 10 [default = 0];
  if (has_activemodelcrc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->activemodelcrc(), target);
  }

  // optional string modelname = 11;
  if (has_modelname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->modelname().data(), this->modelname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "modelname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->modelname(), target);
  }

  // optional string name = 12;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RecastIO.NodeState)
  return target;
}

int NodeState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[3 / 32] & (0xffu << (3 % 32))) {
    // optional bool enabled = 5 [default = true];
    if (has_enabled()) {
      total_size += 1 + 1;
    }

    // optional .RecastIO.ShapeMode shapemode = 6 [default = SHAPE_TRIANGLES];
    if (has_shapemode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->shapemode());
    }

    // optional bool solid = 7 [default = true];
    if (has_solid()) {
      total_size += 1 + 1;
    }

    // optional bool dynamic = 8 [default = false];
    if (has_dynamic()) {
      total_size += 1 + 1;
    }

    // optional uint64 navFlagOverride = 9 [default = 0];
    if (has_navflagoverride()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->navflagoverride());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 activeModelCrc = 10 [default = 0];
    if (has_activemodelcrc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->activemodelcrc());
    }

    // optional string modelname = 11;
    if (has_modelname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->modelname());
    }

    // optional string name = 12;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  switch (type_case()) {
    // optional int32 subModelId = 1;
    case kSubModelId: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->submodelid());
      break;
    }
    // optional int32 staticModelId = 2;
    case kStaticModelId: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->staticmodelid());
      break;
    }
    // optional int32 displacementId = 3;
    case kDisplacementId: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->displacementid());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NodeState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NodeState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NodeState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NodeState::MergeFrom(const NodeState& from) {
  GOOGLE_CHECK_NE(&from, this);
  switch (from.type_case()) {
    case kSubModelId: {
      set_submodelid(from.submodelid());
      break;
    }
    case kStaticModelId: {
      set_staticmodelid(from.staticmodelid());
      break;
    }
    case kDisplacementId: {
      set_displacementid(from.displacementid());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (from._has_bits_[3 / 32] & (0xffu << (3 % 32))) {
    if (from.has_enabled()) {
      set_enabled(from.enabled());
    }
    if (from.has_shapemode()) {
      set_shapemode(from.shapemode());
    }
    if (from.has_solid()) {
      set_solid(from.solid());
    }
    if (from.has_dynamic()) {
      set_dynamic(from.dynamic());
    }
    if (from.has_navflagoverride()) {
      set_navflagoverride(from.navflagoverride());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_activemodelcrc()) {
      set_activemodelcrc(from.activemodelcrc());
    }
    if (from.has_modelname()) {
      set_modelname(from.modelname());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NodeState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NodeState::CopyFrom(const NodeState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeState::IsInitialized() const {

  return true;
}

void NodeState::Swap(NodeState* other) {
  if (other != this) {
    std::swap(enabled_, other->enabled_);
    std::swap(shapemode_, other->shapemode_);
    std::swap(solid_, other->solid_);
    std::swap(dynamic_, other->dynamic_);
    std::swap(navflagoverride_, other->navflagoverride_);
    std::swap(activemodelcrc_, other->activemodelcrc_);
    std::swap(modelname_, other->modelname_);
    std::swap(name_, other->name_);
    std::swap(type_, other->type_);
    std::swap(_oneof_case_[0], other->_oneof_case_[0]);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NodeState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NodeState_descriptor_;
  metadata.reflection = NodeState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NavigationMesh::kVersionFieldNumber;
const int NavigationMesh::kNavMeshParamsFieldNumber;
const int NavigationMesh::kExclusionZoneFieldNumber;
const int NavigationMesh::kOffMeshConnectionFieldNumber;
const int NavigationMesh::kNodeStateFieldNumber;
const int NavigationMesh::kModelsFieldNumber;
const int NavigationMesh::kTilesFieldNumber;
#endif  // !_MSC_VER

NavigationMesh::NavigationMesh()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RecastIO.NavigationMesh)
}

void NavigationMesh::InitAsDefaultInstance() {
  navmeshparams_ = const_cast< ::RecastIO::NavMeshParams*>(&::RecastIO::NavMeshParams::default_instance());
}

NavigationMesh::NavigationMesh(const NavigationMesh& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RecastIO.NavigationMesh)
}

void NavigationMesh::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0;
  navmeshparams_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NavigationMesh::~NavigationMesh() {
  // @@protoc_insertion_point(destructor:RecastIO.NavigationMesh)
  SharedDtor();
}

void NavigationMesh::SharedDtor() {
  if (this != default_instance_) {
    delete navmeshparams_;
  }
}

void NavigationMesh::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NavigationMesh::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NavigationMesh_descriptor_;
}

const NavigationMesh& NavigationMesh::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_recast_2eproto();
  return *default_instance_;
}

NavigationMesh* NavigationMesh::default_instance_ = NULL;

NavigationMesh* NavigationMesh::New() const {
  return new NavigationMesh;
}

void NavigationMesh::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    version_ = 0;
    if (has_navmeshparams()) {
      if (navmeshparams_ != NULL) navmeshparams_->::RecastIO::NavMeshParams::Clear();
    }
  }
  exclusionzone_.Clear();
  offmeshconnection_.Clear();
  nodestate_.Clear();
  models_.Clear();
  tiles_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NavigationMesh::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RecastIO.NavigationMesh)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 version = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_navMeshParams;
        break;
      }

      // required .RecastIO.NavMeshParams navMeshParams = 2;
      case 2: {
        if (tag == 18) {
         parse_navMeshParams:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_navmeshparams()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_exclusionZone;
        break;
      }

      // repeated .RecastIO.AxisAlignedBounds exclusionZone = 3;
      case 3: {
        if (tag == 26) {
         parse_exclusionZone:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_exclusionzone()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_exclusionZone;
        if (input->ExpectTag(34)) goto parse_offMeshConnection;
        break;
      }

      // repeated .RecastIO.OffMeshConnection offMeshConnection = 4;
      case 4: {
        if (tag == 34) {
         parse_offMeshConnection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_offmeshconnection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_offMeshConnection;
        if (input->ExpectTag(42)) goto parse_nodeState;
        break;
      }

      // repeated .RecastIO.NodeState nodeState = 5;
      case 5: {
        if (tag == 42) {
         parse_nodeState:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_nodestate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_nodeState;
        if (input->ExpectTag(50)) goto parse_models;
        break;
      }

      // repeated .RecastIO.Model models = 6;
      case 6: {
        if (tag == 50) {
         parse_models:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_models()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_models;
        if (input->ExpectTag(802)) goto parse_tiles;
        break;
      }

      // repeated .RecastIO.Tile tiles = 100;
      case 100: {
        if (tag == 802) {
         parse_tiles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tiles()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(802)) goto parse_tiles;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RecastIO.NavigationMesh)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RecastIO.NavigationMesh)
  return false;
#undef DO_
}

void NavigationMesh::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RecastIO.NavigationMesh)
  // required int32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->version(), output);
  }

  // required .RecastIO.NavMeshParams navMeshParams = 2;
  if (has_navmeshparams()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->navmeshparams(), output);
  }

  // repeated .RecastIO.AxisAlignedBounds exclusionZone = 3;
  for (int i = 0; i < this->exclusionzone_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->exclusionzone(i), output);
  }

  // repeated .RecastIO.OffMeshConnection offMeshConnection = 4;
  for (int i = 0; i < this->offmeshconnection_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->offmeshconnection(i), output);
  }

  // repeated .RecastIO.NodeState nodeState = 5;
  for (int i = 0; i < this->nodestate_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->nodestate(i), output);
  }

  // repeated .RecastIO.Model models = 6;
  for (int i = 0; i < this->models_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->models(i), output);
  }

  // repeated .RecastIO.Tile tiles = 100;
  for (int i = 0; i < this->tiles_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      100, this->tiles(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RecastIO.NavigationMesh)
}

::google::protobuf::uint8* NavigationMesh::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RecastIO.NavigationMesh)
  // required int32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->version(), target);
  }

  // required .RecastIO.NavMeshParams navMeshParams = 2;
  if (has_navmeshparams()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->navmeshparams(), target);
  }

  // repeated .RecastIO.AxisAlignedBounds exclusionZone = 3;
  for (int i = 0; i < this->exclusionzone_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->exclusionzone(i), target);
  }

  // repeated .RecastIO.OffMeshConnection offMeshConnection = 4;
  for (int i = 0; i < this->offmeshconnection_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->offmeshconnection(i), target);
  }

  // repeated .RecastIO.NodeState nodeState = 5;
  for (int i = 0; i < this->nodestate_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->nodestate(i), target);
  }

  // repeated .RecastIO.Model models = 6;
  for (int i = 0; i < this->models_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->models(i), target);
  }

  // repeated .RecastIO.Tile tiles = 100;
  for (int i = 0; i < this->tiles_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        100, this->tiles(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RecastIO.NavigationMesh)
  return target;
}

int NavigationMesh::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->version());
    }

    // required .RecastIO.NavMeshParams navMeshParams = 2;
    if (has_navmeshparams()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->navmeshparams());
    }

  }
  // repeated .RecastIO.AxisAlignedBounds exclusionZone = 3;
  total_size += 1 * this->exclusionzone_size();
  for (int i = 0; i < this->exclusionzone_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->exclusionzone(i));
  }

  // repeated .RecastIO.OffMeshConnection offMeshConnection = 4;
  total_size += 1 * this->offmeshconnection_size();
  for (int i = 0; i < this->offmeshconnection_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->offmeshconnection(i));
  }

  // repeated .RecastIO.NodeState nodeState = 5;
  total_size += 1 * this->nodestate_size();
  for (int i = 0; i < this->nodestate_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->nodestate(i));
  }

  // repeated .RecastIO.Model models = 6;
  total_size += 1 * this->models_size();
  for (int i = 0; i < this->models_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->models(i));
  }

  // repeated .RecastIO.Tile tiles = 100;
  total_size += 2 * this->tiles_size();
  for (int i = 0; i < this->tiles_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tiles(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NavigationMesh::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NavigationMesh* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NavigationMesh*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NavigationMesh::MergeFrom(const NavigationMesh& from) {
  GOOGLE_CHECK_NE(&from, this);
  exclusionzone_.MergeFrom(from.exclusionzone_);
  offmeshconnection_.MergeFrom(from.offmeshconnection_);
  nodestate_.MergeFrom(from.nodestate_);
  models_.MergeFrom(from.models_);
  tiles_.MergeFrom(from.tiles_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_navmeshparams()) {
      mutable_navmeshparams()->::RecastIO::NavMeshParams::MergeFrom(from.navmeshparams());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NavigationMesh::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NavigationMesh::CopyFrom(const NavigationMesh& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NavigationMesh::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_navmeshparams()) {
    if (!this->navmeshparams().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->exclusionzone())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->offmeshconnection())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->models())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->tiles())) return false;
  return true;
}

void NavigationMesh::Swap(NavigationMesh* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(navmeshparams_, other->navmeshparams_);
    exclusionzone_.Swap(&other->exclusionzone_);
    offmeshconnection_.Swap(&other->offmeshconnection_);
    nodestate_.Swap(&other->nodestate_);
    models_.Swap(&other->models_);
    tiles_.Swap(&other->tiles_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NavigationMesh::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NavigationMesh_descriptor_;
  metadata.reflection = NavigationMesh_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace RecastIO

// @@protoc_insertion_point(global_scope)
