// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: recast.proto

#ifndef PROTOBUF_recast_2eproto__INCLUDED
#define PROTOBUF_recast_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace RecastIO {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_recast_2eproto();
void protobuf_AssignDesc_recast_2eproto();
void protobuf_ShutdownFile_recast_2eproto();

class Vec3;
class AxisAlignedBounds;
class NavMeshParams;
class Tile;
class OffMeshConnection;
class Material;
class Model;
class Model_TriParms;
class NodeState;
class NavigationMesh;

enum ShapeMode {
  SHAPE_TRIANGLES = 0,
  SHAPE_OBB = 1
};
bool ShapeMode_IsValid(int value);
const ShapeMode ShapeMode_MIN = SHAPE_TRIANGLES;
const ShapeMode ShapeMode_MAX = SHAPE_OBB;
const int ShapeMode_ARRAYSIZE = ShapeMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShapeMode_descriptor();
inline const ::std::string& ShapeMode_Name(ShapeMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShapeMode_descriptor(), value);
}
inline bool ShapeMode_Parse(
    const ::std::string& name, ShapeMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShapeMode>(
    ShapeMode_descriptor(), name, value);
}
// ===================================================================

class Vec3 : public ::google::protobuf::Message {
 public:
  Vec3();
  virtual ~Vec3();

  Vec3(const Vec3& from);

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec3& default_instance();

  void Swap(Vec3* other);

  // implements Message ----------------------------------------------

  Vec3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec3& from);
  void MergeFrom(const Vec3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:RecastIO.Vec3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static Vec3* default_instance_;
};
// -------------------------------------------------------------------

class AxisAlignedBounds : public ::google::protobuf::Message {
 public:
  AxisAlignedBounds();
  virtual ~AxisAlignedBounds();

  AxisAlignedBounds(const AxisAlignedBounds& from);

  inline AxisAlignedBounds& operator=(const AxisAlignedBounds& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AxisAlignedBounds& default_instance();

  void Swap(AxisAlignedBounds* other);

  // implements Message ----------------------------------------------

  AxisAlignedBounds* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AxisAlignedBounds& from);
  void MergeFrom(const AxisAlignedBounds& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RecastIO.Vec3 mins = 1;
  inline bool has_mins() const;
  inline void clear_mins();
  static const int kMinsFieldNumber = 1;
  inline const ::RecastIO::Vec3& mins() const;
  inline ::RecastIO::Vec3* mutable_mins();
  inline ::RecastIO::Vec3* release_mins();
  inline void set_allocated_mins(::RecastIO::Vec3* mins);

  // required .RecastIO.Vec3 maxs = 2;
  inline bool has_maxs() const;
  inline void clear_maxs();
  static const int kMaxsFieldNumber = 2;
  inline const ::RecastIO::Vec3& maxs() const;
  inline ::RecastIO::Vec3* mutable_maxs();
  inline ::RecastIO::Vec3* release_maxs();
  inline void set_allocated_maxs(::RecastIO::Vec3* maxs);

  // @@protoc_insertion_point(class_scope:RecastIO.AxisAlignedBounds)
 private:
  inline void set_has_mins();
  inline void clear_has_mins();
  inline void set_has_maxs();
  inline void clear_has_maxs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RecastIO::Vec3* mins_;
  ::RecastIO::Vec3* maxs_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static AxisAlignedBounds* default_instance_;
};
// -------------------------------------------------------------------

class NavMeshParams : public ::google::protobuf::Message {
 public:
  NavMeshParams();
  virtual ~NavMeshParams();

  NavMeshParams(const NavMeshParams& from);

  inline NavMeshParams& operator=(const NavMeshParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavMeshParams& default_instance();

  void Swap(NavMeshParams* other);

  // implements Message ----------------------------------------------

  NavMeshParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NavMeshParams& from);
  void MergeFrom(const NavMeshParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float agentHeightStand = 1;
  inline bool has_agentheightstand() const;
  inline void clear_agentheightstand();
  static const int kAgentHeightStandFieldNumber = 1;
  inline float agentheightstand() const;
  inline void set_agentheightstand(float value);

  // required float agentHeightCrouch = 2;
  inline bool has_agentheightcrouch() const;
  inline void clear_agentheightcrouch();
  static const int kAgentHeightCrouchFieldNumber = 2;
  inline float agentheightcrouch() const;
  inline void set_agentheightcrouch(float value);

  // required float agentRadius = 3;
  inline bool has_agentradius() const;
  inline void clear_agentradius();
  static const int kAgentRadiusFieldNumber = 3;
  inline float agentradius() const;
  inline void set_agentradius(float value);

  // required float agentClimb = 4;
  inline bool has_agentclimb() const;
  inline void clear_agentclimb();
  static const int kAgentClimbFieldNumber = 4;
  inline float agentclimb() const;
  inline void set_agentclimb(float value);

  // required float walkSlopeAngle = 5;
  inline bool has_walkslopeangle() const;
  inline void clear_walkslopeangle();
  static const int kWalkSlopeAngleFieldNumber = 5;
  inline float walkslopeangle() const;
  inline void set_walkslopeangle(float value);

  // required float cellSize = 6;
  inline bool has_cellsize() const;
  inline void clear_cellsize();
  static const int kCellSizeFieldNumber = 6;
  inline float cellsize() const;
  inline void set_cellsize(float value);

  // required float cellHeight = 7;
  inline bool has_cellheight() const;
  inline void clear_cellheight();
  static const int kCellHeightFieldNumber = 7;
  inline float cellheight() const;
  inline void set_cellheight(float value);

  // required float edgeMaxLength = 8;
  inline bool has_edgemaxlength() const;
  inline void clear_edgemaxlength();
  static const int kEdgeMaxLengthFieldNumber = 8;
  inline float edgemaxlength() const;
  inline void set_edgemaxlength(float value);

  // required float edgeMaxError = 9;
  inline bool has_edgemaxerror() const;
  inline void clear_edgemaxerror();
  static const int kEdgeMaxErrorFieldNumber = 9;
  inline float edgemaxerror() const;
  inline void set_edgemaxerror(float value);

  // required int32 tileSize = 10;
  inline bool has_tilesize() const;
  inline void clear_tilesize();
  static const int kTileSizeFieldNumber = 10;
  inline ::google::protobuf::int32 tilesize() const;
  inline void set_tilesize(::google::protobuf::int32 value);

  // required float detailSampleDist = 11;
  inline bool has_detailsampledist() const;
  inline void clear_detailsampledist();
  static const int kDetailSampleDistFieldNumber = 11;
  inline float detailsampledist() const;
  inline void set_detailsampledist(float value);

  // required float detailSampleMaxErr = 12;
  inline bool has_detailsamplemaxerr() const;
  inline void clear_detailsamplemaxerr();
  static const int kDetailSampleMaxErrFieldNumber = 12;
  inline float detailsamplemaxerr() const;
  inline void set_detailsamplemaxerr(float value);

  // @@protoc_insertion_point(class_scope:RecastIO.NavMeshParams)
 private:
  inline void set_has_agentheightstand();
  inline void clear_has_agentheightstand();
  inline void set_has_agentheightcrouch();
  inline void clear_has_agentheightcrouch();
  inline void set_has_agentradius();
  inline void clear_has_agentradius();
  inline void set_has_agentclimb();
  inline void clear_has_agentclimb();
  inline void set_has_walkslopeangle();
  inline void clear_has_walkslopeangle();
  inline void set_has_cellsize();
  inline void clear_has_cellsize();
  inline void set_has_cellheight();
  inline void clear_has_cellheight();
  inline void set_has_edgemaxlength();
  inline void clear_has_edgemaxlength();
  inline void set_has_edgemaxerror();
  inline void clear_has_edgemaxerror();
  inline void set_has_tilesize();
  inline void clear_has_tilesize();
  inline void set_has_detailsampledist();
  inline void clear_has_detailsampledist();
  inline void set_has_detailsamplemaxerr();
  inline void clear_has_detailsamplemaxerr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float agentheightstand_;
  float agentheightcrouch_;
  float agentradius_;
  float agentclimb_;
  float walkslopeangle_;
  float cellsize_;
  float cellheight_;
  float edgemaxlength_;
  float edgemaxerror_;
  ::google::protobuf::int32 tilesize_;
  float detailsampledist_;
  float detailsamplemaxerr_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static NavMeshParams* default_instance_;
};
// -------------------------------------------------------------------

class Tile : public ::google::protobuf::Message {
 public:
  Tile();
  virtual ~Tile();

  Tile(const Tile& from);

  inline Tile& operator=(const Tile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tile& default_instance();

  void Swap(Tile* other);

  // implements Message ----------------------------------------------

  Tile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tile& from);
  void MergeFrom(const Tile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 unCompressedSize = 1;
  inline bool has_uncompressedsize() const;
  inline void clear_uncompressedsize();
  static const int kUnCompressedSizeFieldNumber = 1;
  inline ::google::protobuf::int32 uncompressedsize() const;
  inline void set_uncompressedsize(::google::protobuf::int32 value);

  // required bytes compressedData = 2;
  inline bool has_compresseddata() const;
  inline void clear_compresseddata();
  static const int kCompressedDataFieldNumber = 2;
  inline const ::std::string& compresseddata() const;
  inline void set_compresseddata(const ::std::string& value);
  inline void set_compresseddata(const char* value);
  inline void set_compresseddata(const void* value, size_t size);
  inline ::std::string* mutable_compresseddata();
  inline ::std::string* release_compresseddata();
  inline void set_allocated_compresseddata(::std::string* compresseddata);

  // @@protoc_insertion_point(class_scope:RecastIO.Tile)
 private:
  inline void set_has_uncompressedsize();
  inline void clear_has_uncompressedsize();
  inline void set_has_compresseddata();
  inline void clear_has_compresseddata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* compresseddata_;
  ::google::protobuf::int32 uncompressedsize_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static Tile* default_instance_;
};
// -------------------------------------------------------------------

class OffMeshConnection : public ::google::protobuf::Message {
 public:
  OffMeshConnection();
  virtual ~OffMeshConnection();

  OffMeshConnection(const OffMeshConnection& from);

  inline OffMeshConnection& operator=(const OffMeshConnection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OffMeshConnection& default_instance();

  void Swap(OffMeshConnection* other);

  // implements Message ----------------------------------------------

  OffMeshConnection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OffMeshConnection& from);
  void MergeFrom(const OffMeshConnection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RecastIO.Vec3 entryPos = 1;
  inline bool has_entrypos() const;
  inline void clear_entrypos();
  static const int kEntryPosFieldNumber = 1;
  inline const ::RecastIO::Vec3& entrypos() const;
  inline ::RecastIO::Vec3* mutable_entrypos();
  inline ::RecastIO::Vec3* release_entrypos();
  inline void set_allocated_entrypos(::RecastIO::Vec3* entrypos);

  // required .RecastIO.Vec3 exitPos = 2;
  inline bool has_exitpos() const;
  inline void clear_exitpos();
  static const int kExitPosFieldNumber = 2;
  inline const ::RecastIO::Vec3& exitpos() const;
  inline ::RecastIO::Vec3* mutable_exitpos();
  inline ::RecastIO::Vec3* release_exitpos();
  inline void set_allocated_exitpos(::RecastIO::Vec3* exitpos);

  // repeated .RecastIO.Vec3 vertices = 3;
  inline int vertices_size() const;
  inline void clear_vertices();
  static const int kVerticesFieldNumber = 3;
  inline const ::RecastIO::Vec3& vertices(int index) const;
  inline ::RecastIO::Vec3* mutable_vertices(int index);
  inline ::RecastIO::Vec3* add_vertices();
  inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::Vec3 >&
      vertices() const;
  inline ::google::protobuf::RepeatedPtrField< ::RecastIO::Vec3 >*
      mutable_vertices();

  // required float radius = 4;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 4;
  inline float radius() const;
  inline void set_radius(float value);

  // required uint64 areaflags = 5;
  inline bool has_areaflags() const;
  inline void clear_areaflags();
  static const int kAreaflagsFieldNumber = 5;
  inline ::google::protobuf::uint64 areaflags() const;
  inline void set_areaflags(::google::protobuf::uint64 value);

  // optional bool biDirectional = 6 [default = false];
  inline bool has_bidirectional() const;
  inline void clear_bidirectional();
  static const int kBiDirectionalFieldNumber = 6;
  inline bool bidirectional() const;
  inline void set_bidirectional(bool value);

  // @@protoc_insertion_point(class_scope:RecastIO.OffMeshConnection)
 private:
  inline void set_has_entrypos();
  inline void clear_has_entrypos();
  inline void set_has_exitpos();
  inline void clear_has_exitpos();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_areaflags();
  inline void clear_has_areaflags();
  inline void set_has_bidirectional();
  inline void clear_has_bidirectional();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RecastIO::Vec3* entrypos_;
  ::RecastIO::Vec3* exitpos_;
  ::google::protobuf::RepeatedPtrField< ::RecastIO::Vec3 > vertices_;
  ::google::protobuf::uint64 areaflags_;
  float radius_;
  bool bidirectional_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static OffMeshConnection* default_instance_;
};
// -------------------------------------------------------------------

class Material : public ::google::protobuf::Message {
 public:
  Material();
  virtual ~Material();

  Material(const Material& from);

  inline Material& operator=(const Material& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Material& default_instance();

  void Swap(Material* other);

  // implements Message ----------------------------------------------

  Material* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Material& from);
  void MergeFrom(const Material& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 contents = 2;
  inline bool has_contents() const;
  inline void clear_contents();
  static const int kContentsFieldNumber = 2;
  inline ::google::protobuf::uint32 contents() const;
  inline void set_contents(::google::protobuf::uint32 value);

  // optional uint32 surfaceflags = 3;
  inline bool has_surfaceflags() const;
  inline void clear_surfaceflags();
  static const int kSurfaceflagsFieldNumber = 3;
  inline ::google::protobuf::uint32 surfaceflags() const;
  inline void set_surfaceflags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RecastIO.Material)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_contents();
  inline void clear_has_contents();
  inline void set_has_surfaceflags();
  inline void clear_has_surfaceflags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 contents_;
  ::google::protobuf::uint32 surfaceflags_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static Material* default_instance_;
};
// -------------------------------------------------------------------

class Model_TriParms : public ::google::protobuf::Message {
 public:
  Model_TriParms();
  virtual ~Model_TriParms();

  Model_TriParms(const Model_TriParms& from);

  inline Model_TriParms& operator=(const Model_TriParms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Model_TriParms& default_instance();

  void Swap(Model_TriParms* other);

  // implements Message ----------------------------------------------

  Model_TriParms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Model_TriParms& from);
  void MergeFrom(const Model_TriParms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 tri = 1;
  inline bool has_tri() const;
  inline void clear_tri();
  static const int kTriFieldNumber = 1;
  inline ::google::protobuf::uint32 tri() const;
  inline void set_tri(::google::protobuf::uint32 value);

  // optional uint32 surfaceOverride = 2;
  inline bool has_surfaceoverride() const;
  inline void clear_surfaceoverride();
  static const int kSurfaceOverrideFieldNumber = 2;
  inline ::google::protobuf::uint32 surfaceoverride() const;
  inline void set_surfaceoverride(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RecastIO.Model.TriParms)
 private:
  inline void set_has_tri();
  inline void clear_has_tri();
  inline void set_has_surfaceoverride();
  inline void clear_has_surfaceoverride();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 tri_;
  ::google::protobuf::uint32 surfaceoverride_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static Model_TriParms* default_instance_;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();

  void Swap(Model* other);

  // implements Message ----------------------------------------------

  Model* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Model_TriParms TriParms;

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 modelcrc = 2;
  inline bool has_modelcrc() const;
  inline void clear_modelcrc();
  static const int kModelcrcFieldNumber = 2;
  inline ::google::protobuf::uint32 modelcrc() const;
  inline void set_modelcrc(::google::protobuf::uint32 value);

  // required uint32 numMeshTris = 3;
  inline bool has_nummeshtris() const;
  inline void clear_nummeshtris();
  static const int kNumMeshTrisFieldNumber = 3;
  inline ::google::protobuf::uint32 nummeshtris() const;
  inline void set_nummeshtris(::google::protobuf::uint32 value);

  // repeated .RecastIO.Model.TriParms triangles = 4;
  inline int triangles_size() const;
  inline void clear_triangles();
  static const int kTrianglesFieldNumber = 4;
  inline const ::RecastIO::Model_TriParms& triangles(int index) const;
  inline ::RecastIO::Model_TriParms* mutable_triangles(int index);
  inline ::RecastIO::Model_TriParms* add_triangles();
  inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::Model_TriParms >&
      triangles() const;
  inline ::google::protobuf::RepeatedPtrField< ::RecastIO::Model_TriParms >*
      mutable_triangles();

  // @@protoc_insertion_point(class_scope:RecastIO.Model)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_modelcrc();
  inline void clear_has_modelcrc();
  inline void set_has_nummeshtris();
  inline void clear_has_nummeshtris();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 modelcrc_;
  ::google::protobuf::uint32 nummeshtris_;
  ::google::protobuf::RepeatedPtrField< ::RecastIO::Model_TriParms > triangles_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static Model* default_instance_;
};
// -------------------------------------------------------------------

class NodeState : public ::google::protobuf::Message {
 public:
  NodeState();
  virtual ~NodeState();

  NodeState(const NodeState& from);

  inline NodeState& operator=(const NodeState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeState& default_instance();

  enum TypeCase {
    kSubModelId = 1,
    kStaticModelId = 2,
    kDisplacementId = 3,
    TYPE_NOT_SET = 0,
  };

  void Swap(NodeState* other);

  // implements Message ----------------------------------------------

  NodeState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeState& from);
  void MergeFrom(const NodeState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 subModelId = 1;
  inline bool has_submodelid() const;
  inline void clear_submodelid();
  static const int kSubModelIdFieldNumber = 1;
  inline ::google::protobuf::int32 submodelid() const;
  inline void set_submodelid(::google::protobuf::int32 value);

  // optional int32 staticModelId = 2;
  inline bool has_staticmodelid() const;
  inline void clear_staticmodelid();
  static const int kStaticModelIdFieldNumber = 2;
  inline ::google::protobuf::int32 staticmodelid() const;
  inline void set_staticmodelid(::google::protobuf::int32 value);

  // optional int32 displacementId = 3;
  inline bool has_displacementid() const;
  inline void clear_displacementid();
  static const int kDisplacementIdFieldNumber = 3;
  inline ::google::protobuf::int32 displacementid() const;
  inline void set_displacementid(::google::protobuf::int32 value);

  // optional bool enabled = 5 [default = true];
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 5;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional .RecastIO.ShapeMode shapemode = 6 [default = SHAPE_TRIANGLES];
  inline bool has_shapemode() const;
  inline void clear_shapemode();
  static const int kShapemodeFieldNumber = 6;
  inline ::RecastIO::ShapeMode shapemode() const;
  inline void set_shapemode(::RecastIO::ShapeMode value);

  // optional bool solid = 7 [default = true];
  inline bool has_solid() const;
  inline void clear_solid();
  static const int kSolidFieldNumber = 7;
  inline bool solid() const;
  inline void set_solid(bool value);

  // optional bool dynamic = 8 [default = false];
  inline bool has_dynamic() const;
  inline void clear_dynamic();
  static const int kDynamicFieldNumber = 8;
  inline bool dynamic() const;
  inline void set_dynamic(bool value);

  // optional uint64 navFlagOverride = 9 [default = 0];
  inline bool has_navflagoverride() const;
  inline void clear_navflagoverride();
  static const int kNavFlagOverrideFieldNumber = 9;
  inline ::google::protobuf::uint64 navflagoverride() const;
  inline void set_navflagoverride(::google::protobuf::uint64 value);

  // optional uint32 activeModelCrc = 10 [default = 0];
  inline bool has_activemodelcrc() const;
  inline void clear_activemodelcrc();
  static const int kActiveModelCrcFieldNumber = 10;
  inline ::google::protobuf::uint32 activemodelcrc() const;
  inline void set_activemodelcrc(::google::protobuf::uint32 value);

  // optional string modelname = 11;
  inline bool has_modelname() const;
  inline void clear_modelname();
  static const int kModelnameFieldNumber = 11;
  inline const ::std::string& modelname() const;
  inline void set_modelname(const ::std::string& value);
  inline void set_modelname(const char* value);
  inline void set_modelname(const char* value, size_t size);
  inline ::std::string* mutable_modelname();
  inline ::std::string* release_modelname();
  inline void set_allocated_modelname(::std::string* modelname);

  // optional string name = 12;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 12;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  inline TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:RecastIO.NodeState)
 private:
  inline void set_has_submodelid();
  inline void set_has_staticmodelid();
  inline void set_has_displacementid();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_shapemode();
  inline void clear_has_shapemode();
  inline void set_has_solid();
  inline void clear_has_solid();
  inline void set_has_dynamic();
  inline void clear_has_dynamic();
  inline void set_has_navflagoverride();
  inline void clear_has_navflagoverride();
  inline void set_has_activemodelcrc();
  inline void clear_has_activemodelcrc();
  inline void set_has_modelname();
  inline void clear_has_modelname();
  inline void set_has_name();
  inline void clear_has_name();

  inline bool has_type();
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int shapemode_;
  bool enabled_;
  bool solid_;
  bool dynamic_;
  ::google::protobuf::uint64 navflagoverride_;
  ::std::string* modelname_;
  ::std::string* name_;
  ::google::protobuf::uint32 activemodelcrc_;
  union TypeUnion {
    ::google::protobuf::int32 submodelid_;
    ::google::protobuf::int32 staticmodelid_;
    ::google::protobuf::int32 displacementid_;
  } type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static NodeState* default_instance_;
};
// -------------------------------------------------------------------

class NavigationMesh : public ::google::protobuf::Message {
 public:
  NavigationMesh();
  virtual ~NavigationMesh();

  NavigationMesh(const NavigationMesh& from);

  inline NavigationMesh& operator=(const NavigationMesh& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavigationMesh& default_instance();

  void Swap(NavigationMesh* other);

  // implements Message ----------------------------------------------

  NavigationMesh* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NavigationMesh& from);
  void MergeFrom(const NavigationMesh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // required .RecastIO.NavMeshParams navMeshParams = 2;
  inline bool has_navmeshparams() const;
  inline void clear_navmeshparams();
  static const int kNavMeshParamsFieldNumber = 2;
  inline const ::RecastIO::NavMeshParams& navmeshparams() const;
  inline ::RecastIO::NavMeshParams* mutable_navmeshparams();
  inline ::RecastIO::NavMeshParams* release_navmeshparams();
  inline void set_allocated_navmeshparams(::RecastIO::NavMeshParams* navmeshparams);

  // repeated .RecastIO.AxisAlignedBounds exclusionZone = 3;
  inline int exclusionzone_size() const;
  inline void clear_exclusionzone();
  static const int kExclusionZoneFieldNumber = 3;
  inline const ::RecastIO::AxisAlignedBounds& exclusionzone(int index) const;
  inline ::RecastIO::AxisAlignedBounds* mutable_exclusionzone(int index);
  inline ::RecastIO::AxisAlignedBounds* add_exclusionzone();
  inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::AxisAlignedBounds >&
      exclusionzone() const;
  inline ::google::protobuf::RepeatedPtrField< ::RecastIO::AxisAlignedBounds >*
      mutable_exclusionzone();

  // repeated .RecastIO.OffMeshConnection offMeshConnection = 4;
  inline int offmeshconnection_size() const;
  inline void clear_offmeshconnection();
  static const int kOffMeshConnectionFieldNumber = 4;
  inline const ::RecastIO::OffMeshConnection& offmeshconnection(int index) const;
  inline ::RecastIO::OffMeshConnection* mutable_offmeshconnection(int index);
  inline ::RecastIO::OffMeshConnection* add_offmeshconnection();
  inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::OffMeshConnection >&
      offmeshconnection() const;
  inline ::google::protobuf::RepeatedPtrField< ::RecastIO::OffMeshConnection >*
      mutable_offmeshconnection();

  // repeated .RecastIO.NodeState nodeState = 5;
  inline int nodestate_size() const;
  inline void clear_nodestate();
  static const int kNodeStateFieldNumber = 5;
  inline const ::RecastIO::NodeState& nodestate(int index) const;
  inline ::RecastIO::NodeState* mutable_nodestate(int index);
  inline ::RecastIO::NodeState* add_nodestate();
  inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::NodeState >&
      nodestate() const;
  inline ::google::protobuf::RepeatedPtrField< ::RecastIO::NodeState >*
      mutable_nodestate();

  // repeated .RecastIO.Model models = 6;
  inline int models_size() const;
  inline void clear_models();
  static const int kModelsFieldNumber = 6;
  inline const ::RecastIO::Model& models(int index) const;
  inline ::RecastIO::Model* mutable_models(int index);
  inline ::RecastIO::Model* add_models();
  inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::Model >&
      models() const;
  inline ::google::protobuf::RepeatedPtrField< ::RecastIO::Model >*
      mutable_models();

  // repeated .RecastIO.Tile tiles = 100;
  inline int tiles_size() const;
  inline void clear_tiles();
  static const int kTilesFieldNumber = 100;
  inline const ::RecastIO::Tile& tiles(int index) const;
  inline ::RecastIO::Tile* mutable_tiles(int index);
  inline ::RecastIO::Tile* add_tiles();
  inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::Tile >&
      tiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::RecastIO::Tile >*
      mutable_tiles();

  // @@protoc_insertion_point(class_scope:RecastIO.NavigationMesh)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_navmeshparams();
  inline void clear_has_navmeshparams();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RecastIO::NavMeshParams* navmeshparams_;
  ::google::protobuf::RepeatedPtrField< ::RecastIO::AxisAlignedBounds > exclusionzone_;
  ::google::protobuf::RepeatedPtrField< ::RecastIO::OffMeshConnection > offmeshconnection_;
  ::google::protobuf::RepeatedPtrField< ::RecastIO::NodeState > nodestate_;
  ::google::protobuf::RepeatedPtrField< ::RecastIO::Model > models_;
  ::google::protobuf::RepeatedPtrField< ::RecastIO::Tile > tiles_;
  ::google::protobuf::int32 version_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static NavigationMesh* default_instance_;
};
// ===================================================================


// ===================================================================

// Vec3

// optional float x = 1;
inline bool Vec3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vec3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vec3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vec3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:RecastIO.Vec3.x)
  return x_;
}
inline void Vec3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.Vec3.x)
}

// optional float y = 2;
inline bool Vec3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vec3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vec3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vec3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:RecastIO.Vec3.y)
  return y_;
}
inline void Vec3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.Vec3.y)
}

// optional float z = 3;
inline bool Vec3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vec3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vec3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vec3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:RecastIO.Vec3.z)
  return z_;
}
inline void Vec3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.Vec3.z)
}

// -------------------------------------------------------------------

// AxisAlignedBounds

// required .RecastIO.Vec3 mins = 1;
inline bool AxisAlignedBounds::has_mins() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AxisAlignedBounds::set_has_mins() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AxisAlignedBounds::clear_has_mins() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AxisAlignedBounds::clear_mins() {
  if (mins_ != NULL) mins_->::RecastIO::Vec3::Clear();
  clear_has_mins();
}
inline const ::RecastIO::Vec3& AxisAlignedBounds::mins() const {
  // @@protoc_insertion_point(field_get:RecastIO.AxisAlignedBounds.mins)
  return mins_ != NULL ? *mins_ : *default_instance_->mins_;
}
inline ::RecastIO::Vec3* AxisAlignedBounds::mutable_mins() {
  set_has_mins();
  if (mins_ == NULL) mins_ = new ::RecastIO::Vec3;
  // @@protoc_insertion_point(field_mutable:RecastIO.AxisAlignedBounds.mins)
  return mins_;
}
inline ::RecastIO::Vec3* AxisAlignedBounds::release_mins() {
  clear_has_mins();
  ::RecastIO::Vec3* temp = mins_;
  mins_ = NULL;
  return temp;
}
inline void AxisAlignedBounds::set_allocated_mins(::RecastIO::Vec3* mins) {
  delete mins_;
  mins_ = mins;
  if (mins) {
    set_has_mins();
  } else {
    clear_has_mins();
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.AxisAlignedBounds.mins)
}

// required .RecastIO.Vec3 maxs = 2;
inline bool AxisAlignedBounds::has_maxs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AxisAlignedBounds::set_has_maxs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AxisAlignedBounds::clear_has_maxs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AxisAlignedBounds::clear_maxs() {
  if (maxs_ != NULL) maxs_->::RecastIO::Vec3::Clear();
  clear_has_maxs();
}
inline const ::RecastIO::Vec3& AxisAlignedBounds::maxs() const {
  // @@protoc_insertion_point(field_get:RecastIO.AxisAlignedBounds.maxs)
  return maxs_ != NULL ? *maxs_ : *default_instance_->maxs_;
}
inline ::RecastIO::Vec3* AxisAlignedBounds::mutable_maxs() {
  set_has_maxs();
  if (maxs_ == NULL) maxs_ = new ::RecastIO::Vec3;
  // @@protoc_insertion_point(field_mutable:RecastIO.AxisAlignedBounds.maxs)
  return maxs_;
}
inline ::RecastIO::Vec3* AxisAlignedBounds::release_maxs() {
  clear_has_maxs();
  ::RecastIO::Vec3* temp = maxs_;
  maxs_ = NULL;
  return temp;
}
inline void AxisAlignedBounds::set_allocated_maxs(::RecastIO::Vec3* maxs) {
  delete maxs_;
  maxs_ = maxs;
  if (maxs) {
    set_has_maxs();
  } else {
    clear_has_maxs();
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.AxisAlignedBounds.maxs)
}

// -------------------------------------------------------------------

// NavMeshParams

// required float agentHeightStand = 1;
inline bool NavMeshParams::has_agentheightstand() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NavMeshParams::set_has_agentheightstand() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NavMeshParams::clear_has_agentheightstand() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NavMeshParams::clear_agentheightstand() {
  agentheightstand_ = 0;
  clear_has_agentheightstand();
}
inline float NavMeshParams::agentheightstand() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.agentHeightStand)
  return agentheightstand_;
}
inline void NavMeshParams::set_agentheightstand(float value) {
  set_has_agentheightstand();
  agentheightstand_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.agentHeightStand)
}

// required float agentHeightCrouch = 2;
inline bool NavMeshParams::has_agentheightcrouch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NavMeshParams::set_has_agentheightcrouch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NavMeshParams::clear_has_agentheightcrouch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NavMeshParams::clear_agentheightcrouch() {
  agentheightcrouch_ = 0;
  clear_has_agentheightcrouch();
}
inline float NavMeshParams::agentheightcrouch() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.agentHeightCrouch)
  return agentheightcrouch_;
}
inline void NavMeshParams::set_agentheightcrouch(float value) {
  set_has_agentheightcrouch();
  agentheightcrouch_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.agentHeightCrouch)
}

// required float agentRadius = 3;
inline bool NavMeshParams::has_agentradius() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NavMeshParams::set_has_agentradius() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NavMeshParams::clear_has_agentradius() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NavMeshParams::clear_agentradius() {
  agentradius_ = 0;
  clear_has_agentradius();
}
inline float NavMeshParams::agentradius() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.agentRadius)
  return agentradius_;
}
inline void NavMeshParams::set_agentradius(float value) {
  set_has_agentradius();
  agentradius_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.agentRadius)
}

// required float agentClimb = 4;
inline bool NavMeshParams::has_agentclimb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NavMeshParams::set_has_agentclimb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NavMeshParams::clear_has_agentclimb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NavMeshParams::clear_agentclimb() {
  agentclimb_ = 0;
  clear_has_agentclimb();
}
inline float NavMeshParams::agentclimb() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.agentClimb)
  return agentclimb_;
}
inline void NavMeshParams::set_agentclimb(float value) {
  set_has_agentclimb();
  agentclimb_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.agentClimb)
}

// required float walkSlopeAngle = 5;
inline bool NavMeshParams::has_walkslopeangle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NavMeshParams::set_has_walkslopeangle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NavMeshParams::clear_has_walkslopeangle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NavMeshParams::clear_walkslopeangle() {
  walkslopeangle_ = 0;
  clear_has_walkslopeangle();
}
inline float NavMeshParams::walkslopeangle() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.walkSlopeAngle)
  return walkslopeangle_;
}
inline void NavMeshParams::set_walkslopeangle(float value) {
  set_has_walkslopeangle();
  walkslopeangle_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.walkSlopeAngle)
}

// required float cellSize = 6;
inline bool NavMeshParams::has_cellsize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NavMeshParams::set_has_cellsize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NavMeshParams::clear_has_cellsize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NavMeshParams::clear_cellsize() {
  cellsize_ = 0;
  clear_has_cellsize();
}
inline float NavMeshParams::cellsize() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.cellSize)
  return cellsize_;
}
inline void NavMeshParams::set_cellsize(float value) {
  set_has_cellsize();
  cellsize_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.cellSize)
}

// required float cellHeight = 7;
inline bool NavMeshParams::has_cellheight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NavMeshParams::set_has_cellheight() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NavMeshParams::clear_has_cellheight() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NavMeshParams::clear_cellheight() {
  cellheight_ = 0;
  clear_has_cellheight();
}
inline float NavMeshParams::cellheight() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.cellHeight)
  return cellheight_;
}
inline void NavMeshParams::set_cellheight(float value) {
  set_has_cellheight();
  cellheight_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.cellHeight)
}

// required float edgeMaxLength = 8;
inline bool NavMeshParams::has_edgemaxlength() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NavMeshParams::set_has_edgemaxlength() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NavMeshParams::clear_has_edgemaxlength() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NavMeshParams::clear_edgemaxlength() {
  edgemaxlength_ = 0;
  clear_has_edgemaxlength();
}
inline float NavMeshParams::edgemaxlength() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.edgeMaxLength)
  return edgemaxlength_;
}
inline void NavMeshParams::set_edgemaxlength(float value) {
  set_has_edgemaxlength();
  edgemaxlength_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.edgeMaxLength)
}

// required float edgeMaxError = 9;
inline bool NavMeshParams::has_edgemaxerror() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NavMeshParams::set_has_edgemaxerror() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NavMeshParams::clear_has_edgemaxerror() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NavMeshParams::clear_edgemaxerror() {
  edgemaxerror_ = 0;
  clear_has_edgemaxerror();
}
inline float NavMeshParams::edgemaxerror() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.edgeMaxError)
  return edgemaxerror_;
}
inline void NavMeshParams::set_edgemaxerror(float value) {
  set_has_edgemaxerror();
  edgemaxerror_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.edgeMaxError)
}

// required int32 tileSize = 10;
inline bool NavMeshParams::has_tilesize() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NavMeshParams::set_has_tilesize() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NavMeshParams::clear_has_tilesize() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NavMeshParams::clear_tilesize() {
  tilesize_ = 0;
  clear_has_tilesize();
}
inline ::google::protobuf::int32 NavMeshParams::tilesize() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.tileSize)
  return tilesize_;
}
inline void NavMeshParams::set_tilesize(::google::protobuf::int32 value) {
  set_has_tilesize();
  tilesize_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.tileSize)
}

// required float detailSampleDist = 11;
inline bool NavMeshParams::has_detailsampledist() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NavMeshParams::set_has_detailsampledist() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NavMeshParams::clear_has_detailsampledist() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NavMeshParams::clear_detailsampledist() {
  detailsampledist_ = 0;
  clear_has_detailsampledist();
}
inline float NavMeshParams::detailsampledist() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.detailSampleDist)
  return detailsampledist_;
}
inline void NavMeshParams::set_detailsampledist(float value) {
  set_has_detailsampledist();
  detailsampledist_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.detailSampleDist)
}

// required float detailSampleMaxErr = 12;
inline bool NavMeshParams::has_detailsamplemaxerr() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NavMeshParams::set_has_detailsamplemaxerr() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NavMeshParams::clear_has_detailsamplemaxerr() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NavMeshParams::clear_detailsamplemaxerr() {
  detailsamplemaxerr_ = 0;
  clear_has_detailsamplemaxerr();
}
inline float NavMeshParams::detailsamplemaxerr() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.detailSampleMaxErr)
  return detailsamplemaxerr_;
}
inline void NavMeshParams::set_detailsamplemaxerr(float value) {
  set_has_detailsamplemaxerr();
  detailsamplemaxerr_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.detailSampleMaxErr)
}

// -------------------------------------------------------------------

// Tile

// required int32 unCompressedSize = 1;
inline bool Tile::has_uncompressedsize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tile::set_has_uncompressedsize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tile::clear_has_uncompressedsize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tile::clear_uncompressedsize() {
  uncompressedsize_ = 0;
  clear_has_uncompressedsize();
}
inline ::google::protobuf::int32 Tile::uncompressedsize() const {
  // @@protoc_insertion_point(field_get:RecastIO.Tile.unCompressedSize)
  return uncompressedsize_;
}
inline void Tile::set_uncompressedsize(::google::protobuf::int32 value) {
  set_has_uncompressedsize();
  uncompressedsize_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.Tile.unCompressedSize)
}

// required bytes compressedData = 2;
inline bool Tile::has_compresseddata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tile::set_has_compresseddata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tile::clear_has_compresseddata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tile::clear_compresseddata() {
  if (compresseddata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compresseddata_->clear();
  }
  clear_has_compresseddata();
}
inline const ::std::string& Tile::compresseddata() const {
  // @@protoc_insertion_point(field_get:RecastIO.Tile.compressedData)
  return *compresseddata_;
}
inline void Tile::set_compresseddata(const ::std::string& value) {
  set_has_compresseddata();
  if (compresseddata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compresseddata_ = new ::std::string;
  }
  compresseddata_->assign(value);
  // @@protoc_insertion_point(field_set:RecastIO.Tile.compressedData)
}
inline void Tile::set_compresseddata(const char* value) {
  set_has_compresseddata();
  if (compresseddata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compresseddata_ = new ::std::string;
  }
  compresseddata_->assign(value);
  // @@protoc_insertion_point(field_set_char:RecastIO.Tile.compressedData)
}
inline void Tile::set_compresseddata(const void* value, size_t size) {
  set_has_compresseddata();
  if (compresseddata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compresseddata_ = new ::std::string;
  }
  compresseddata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RecastIO.Tile.compressedData)
}
inline ::std::string* Tile::mutable_compresseddata() {
  set_has_compresseddata();
  if (compresseddata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compresseddata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RecastIO.Tile.compressedData)
  return compresseddata_;
}
inline ::std::string* Tile::release_compresseddata() {
  clear_has_compresseddata();
  if (compresseddata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = compresseddata_;
    compresseddata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Tile::set_allocated_compresseddata(::std::string* compresseddata) {
  if (compresseddata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete compresseddata_;
  }
  if (compresseddata) {
    set_has_compresseddata();
    compresseddata_ = compresseddata;
  } else {
    clear_has_compresseddata();
    compresseddata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.Tile.compressedData)
}

// -------------------------------------------------------------------

// OffMeshConnection

// required .RecastIO.Vec3 entryPos = 1;
inline bool OffMeshConnection::has_entrypos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OffMeshConnection::set_has_entrypos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OffMeshConnection::clear_has_entrypos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OffMeshConnection::clear_entrypos() {
  if (entrypos_ != NULL) entrypos_->::RecastIO::Vec3::Clear();
  clear_has_entrypos();
}
inline const ::RecastIO::Vec3& OffMeshConnection::entrypos() const {
  // @@protoc_insertion_point(field_get:RecastIO.OffMeshConnection.entryPos)
  return entrypos_ != NULL ? *entrypos_ : *default_instance_->entrypos_;
}
inline ::RecastIO::Vec3* OffMeshConnection::mutable_entrypos() {
  set_has_entrypos();
  if (entrypos_ == NULL) entrypos_ = new ::RecastIO::Vec3;
  // @@protoc_insertion_point(field_mutable:RecastIO.OffMeshConnection.entryPos)
  return entrypos_;
}
inline ::RecastIO::Vec3* OffMeshConnection::release_entrypos() {
  clear_has_entrypos();
  ::RecastIO::Vec3* temp = entrypos_;
  entrypos_ = NULL;
  return temp;
}
inline void OffMeshConnection::set_allocated_entrypos(::RecastIO::Vec3* entrypos) {
  delete entrypos_;
  entrypos_ = entrypos;
  if (entrypos) {
    set_has_entrypos();
  } else {
    clear_has_entrypos();
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.OffMeshConnection.entryPos)
}

// required .RecastIO.Vec3 exitPos = 2;
inline bool OffMeshConnection::has_exitpos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OffMeshConnection::set_has_exitpos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OffMeshConnection::clear_has_exitpos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OffMeshConnection::clear_exitpos() {
  if (exitpos_ != NULL) exitpos_->::RecastIO::Vec3::Clear();
  clear_has_exitpos();
}
inline const ::RecastIO::Vec3& OffMeshConnection::exitpos() const {
  // @@protoc_insertion_point(field_get:RecastIO.OffMeshConnection.exitPos)
  return exitpos_ != NULL ? *exitpos_ : *default_instance_->exitpos_;
}
inline ::RecastIO::Vec3* OffMeshConnection::mutable_exitpos() {
  set_has_exitpos();
  if (exitpos_ == NULL) exitpos_ = new ::RecastIO::Vec3;
  // @@protoc_insertion_point(field_mutable:RecastIO.OffMeshConnection.exitPos)
  return exitpos_;
}
inline ::RecastIO::Vec3* OffMeshConnection::release_exitpos() {
  clear_has_exitpos();
  ::RecastIO::Vec3* temp = exitpos_;
  exitpos_ = NULL;
  return temp;
}
inline void OffMeshConnection::set_allocated_exitpos(::RecastIO::Vec3* exitpos) {
  delete exitpos_;
  exitpos_ = exitpos;
  if (exitpos) {
    set_has_exitpos();
  } else {
    clear_has_exitpos();
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.OffMeshConnection.exitPos)
}

// repeated .RecastIO.Vec3 vertices = 3;
inline int OffMeshConnection::vertices_size() const {
  return vertices_.size();
}
inline void OffMeshConnection::clear_vertices() {
  vertices_.Clear();
}
inline const ::RecastIO::Vec3& OffMeshConnection::vertices(int index) const {
  // @@protoc_insertion_point(field_get:RecastIO.OffMeshConnection.vertices)
  return vertices_.Get(index);
}
inline ::RecastIO::Vec3* OffMeshConnection::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:RecastIO.OffMeshConnection.vertices)
  return vertices_.Mutable(index);
}
inline ::RecastIO::Vec3* OffMeshConnection::add_vertices() {
  // @@protoc_insertion_point(field_add:RecastIO.OffMeshConnection.vertices)
  return vertices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::Vec3 >&
OffMeshConnection::vertices() const {
  // @@protoc_insertion_point(field_list:RecastIO.OffMeshConnection.vertices)
  return vertices_;
}
inline ::google::protobuf::RepeatedPtrField< ::RecastIO::Vec3 >*
OffMeshConnection::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:RecastIO.OffMeshConnection.vertices)
  return &vertices_;
}

// required float radius = 4;
inline bool OffMeshConnection::has_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OffMeshConnection::set_has_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OffMeshConnection::clear_has_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OffMeshConnection::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float OffMeshConnection::radius() const {
  // @@protoc_insertion_point(field_get:RecastIO.OffMeshConnection.radius)
  return radius_;
}
inline void OffMeshConnection::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.OffMeshConnection.radius)
}

// required uint64 areaflags = 5;
inline bool OffMeshConnection::has_areaflags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OffMeshConnection::set_has_areaflags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OffMeshConnection::clear_has_areaflags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OffMeshConnection::clear_areaflags() {
  areaflags_ = GOOGLE_ULONGLONG(0);
  clear_has_areaflags();
}
inline ::google::protobuf::uint64 OffMeshConnection::areaflags() const {
  // @@protoc_insertion_point(field_get:RecastIO.OffMeshConnection.areaflags)
  return areaflags_;
}
inline void OffMeshConnection::set_areaflags(::google::protobuf::uint64 value) {
  set_has_areaflags();
  areaflags_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.OffMeshConnection.areaflags)
}

// optional bool biDirectional = 6 [default = false];
inline bool OffMeshConnection::has_bidirectional() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OffMeshConnection::set_has_bidirectional() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OffMeshConnection::clear_has_bidirectional() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OffMeshConnection::clear_bidirectional() {
  bidirectional_ = false;
  clear_has_bidirectional();
}
inline bool OffMeshConnection::bidirectional() const {
  // @@protoc_insertion_point(field_get:RecastIO.OffMeshConnection.biDirectional)
  return bidirectional_;
}
inline void OffMeshConnection::set_bidirectional(bool value) {
  set_has_bidirectional();
  bidirectional_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.OffMeshConnection.biDirectional)
}

// -------------------------------------------------------------------

// Material

// required string name = 1;
inline bool Material::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Material::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Material::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Material::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Material::name() const {
  // @@protoc_insertion_point(field_get:RecastIO.Material.name)
  return *name_;
}
inline void Material::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:RecastIO.Material.name)
}
inline void Material::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:RecastIO.Material.name)
}
inline void Material::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RecastIO.Material.name)
}
inline ::std::string* Material::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RecastIO.Material.name)
  return name_;
}
inline ::std::string* Material::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Material::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.Material.name)
}

// optional uint32 contents = 2;
inline bool Material::has_contents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Material::set_has_contents() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Material::clear_has_contents() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Material::clear_contents() {
  contents_ = 0u;
  clear_has_contents();
}
inline ::google::protobuf::uint32 Material::contents() const {
  // @@protoc_insertion_point(field_get:RecastIO.Material.contents)
  return contents_;
}
inline void Material::set_contents(::google::protobuf::uint32 value) {
  set_has_contents();
  contents_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.Material.contents)
}

// optional uint32 surfaceflags = 3;
inline bool Material::has_surfaceflags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Material::set_has_surfaceflags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Material::clear_has_surfaceflags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Material::clear_surfaceflags() {
  surfaceflags_ = 0u;
  clear_has_surfaceflags();
}
inline ::google::protobuf::uint32 Material::surfaceflags() const {
  // @@protoc_insertion_point(field_get:RecastIO.Material.surfaceflags)
  return surfaceflags_;
}
inline void Material::set_surfaceflags(::google::protobuf::uint32 value) {
  set_has_surfaceflags();
  surfaceflags_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.Material.surfaceflags)
}

// -------------------------------------------------------------------

// Model_TriParms

// required uint32 tri = 1;
inline bool Model_TriParms::has_tri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Model_TriParms::set_has_tri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Model_TriParms::clear_has_tri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Model_TriParms::clear_tri() {
  tri_ = 0u;
  clear_has_tri();
}
inline ::google::protobuf::uint32 Model_TriParms::tri() const {
  // @@protoc_insertion_point(field_get:RecastIO.Model.TriParms.tri)
  return tri_;
}
inline void Model_TriParms::set_tri(::google::protobuf::uint32 value) {
  set_has_tri();
  tri_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.Model.TriParms.tri)
}

// optional uint32 surfaceOverride = 2;
inline bool Model_TriParms::has_surfaceoverride() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Model_TriParms::set_has_surfaceoverride() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Model_TriParms::clear_has_surfaceoverride() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Model_TriParms::clear_surfaceoverride() {
  surfaceoverride_ = 0u;
  clear_has_surfaceoverride();
}
inline ::google::protobuf::uint32 Model_TriParms::surfaceoverride() const {
  // @@protoc_insertion_point(field_get:RecastIO.Model.TriParms.surfaceOverride)
  return surfaceoverride_;
}
inline void Model_TriParms::set_surfaceoverride(::google::protobuf::uint32 value) {
  set_has_surfaceoverride();
  surfaceoverride_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.Model.TriParms.surfaceOverride)
}

// -------------------------------------------------------------------

// Model

// required string name = 1;
inline bool Model::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Model::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Model::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Model::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Model::name() const {
  // @@protoc_insertion_point(field_get:RecastIO.Model.name)
  return *name_;
}
inline void Model::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:RecastIO.Model.name)
}
inline void Model::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:RecastIO.Model.name)
}
inline void Model::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RecastIO.Model.name)
}
inline ::std::string* Model::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RecastIO.Model.name)
  return name_;
}
inline ::std::string* Model::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Model::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.Model.name)
}

// required uint32 modelcrc = 2;
inline bool Model::has_modelcrc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Model::set_has_modelcrc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Model::clear_has_modelcrc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Model::clear_modelcrc() {
  modelcrc_ = 0u;
  clear_has_modelcrc();
}
inline ::google::protobuf::uint32 Model::modelcrc() const {
  // @@protoc_insertion_point(field_get:RecastIO.Model.modelcrc)
  return modelcrc_;
}
inline void Model::set_modelcrc(::google::protobuf::uint32 value) {
  set_has_modelcrc();
  modelcrc_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.Model.modelcrc)
}

// required uint32 numMeshTris = 3;
inline bool Model::has_nummeshtris() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Model::set_has_nummeshtris() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Model::clear_has_nummeshtris() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Model::clear_nummeshtris() {
  nummeshtris_ = 0u;
  clear_has_nummeshtris();
}
inline ::google::protobuf::uint32 Model::nummeshtris() const {
  // @@protoc_insertion_point(field_get:RecastIO.Model.numMeshTris)
  return nummeshtris_;
}
inline void Model::set_nummeshtris(::google::protobuf::uint32 value) {
  set_has_nummeshtris();
  nummeshtris_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.Model.numMeshTris)
}

// repeated .RecastIO.Model.TriParms triangles = 4;
inline int Model::triangles_size() const {
  return triangles_.size();
}
inline void Model::clear_triangles() {
  triangles_.Clear();
}
inline const ::RecastIO::Model_TriParms& Model::triangles(int index) const {
  // @@protoc_insertion_point(field_get:RecastIO.Model.triangles)
  return triangles_.Get(index);
}
inline ::RecastIO::Model_TriParms* Model::mutable_triangles(int index) {
  // @@protoc_insertion_point(field_mutable:RecastIO.Model.triangles)
  return triangles_.Mutable(index);
}
inline ::RecastIO::Model_TriParms* Model::add_triangles() {
  // @@protoc_insertion_point(field_add:RecastIO.Model.triangles)
  return triangles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::Model_TriParms >&
Model::triangles() const {
  // @@protoc_insertion_point(field_list:RecastIO.Model.triangles)
  return triangles_;
}
inline ::google::protobuf::RepeatedPtrField< ::RecastIO::Model_TriParms >*
Model::mutable_triangles() {
  // @@protoc_insertion_point(field_mutable_list:RecastIO.Model.triangles)
  return &triangles_;
}

// -------------------------------------------------------------------

// NodeState

// optional int32 subModelId = 1;
inline bool NodeState::has_submodelid() const {
  return type_case() == kSubModelId;
}
inline void NodeState::set_has_submodelid() {
  _oneof_case_[0] = kSubModelId;
}
inline void NodeState::clear_submodelid() {
  if (has_submodelid()) {
    type_.submodelid_ = 0;
    clear_has_type();
  }
}
inline ::google::protobuf::int32 NodeState::submodelid() const {
  if (has_submodelid()) {
    return type_.submodelid_;
  }
  return 0;
}
inline void NodeState::set_submodelid(::google::protobuf::int32 value) {
  if (!has_submodelid()) {
    clear_type();
    set_has_submodelid();
  }
  type_.submodelid_ = value;
}

// optional int32 staticModelId = 2;
inline bool NodeState::has_staticmodelid() const {
  return type_case() == kStaticModelId;
}
inline void NodeState::set_has_staticmodelid() {
  _oneof_case_[0] = kStaticModelId;
}
inline void NodeState::clear_staticmodelid() {
  if (has_staticmodelid()) {
    type_.staticmodelid_ = 0;
    clear_has_type();
  }
}
inline ::google::protobuf::int32 NodeState::staticmodelid() const {
  if (has_staticmodelid()) {
    return type_.staticmodelid_;
  }
  return 0;
}
inline void NodeState::set_staticmodelid(::google::protobuf::int32 value) {
  if (!has_staticmodelid()) {
    clear_type();
    set_has_staticmodelid();
  }
  type_.staticmodelid_ = value;
}

// optional int32 displacementId = 3;
inline bool NodeState::has_displacementid() const {
  return type_case() == kDisplacementId;
}
inline void NodeState::set_has_displacementid() {
  _oneof_case_[0] = kDisplacementId;
}
inline void NodeState::clear_displacementid() {
  if (has_displacementid()) {
    type_.displacementid_ = 0;
    clear_has_type();
  }
}
inline ::google::protobuf::int32 NodeState::displacementid() const {
  if (has_displacementid()) {
    return type_.displacementid_;
  }
  return 0;
}
inline void NodeState::set_displacementid(::google::protobuf::int32 value) {
  if (!has_displacementid()) {
    clear_type();
    set_has_displacementid();
  }
  type_.displacementid_ = value;
}

// optional bool enabled = 5 [default = true];
inline bool NodeState::has_enabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeState::set_has_enabled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeState::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeState::clear_enabled() {
  enabled_ = true;
  clear_has_enabled();
}
inline bool NodeState::enabled() const {
  // @@protoc_insertion_point(field_get:RecastIO.NodeState.enabled)
  return enabled_;
}
inline void NodeState::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NodeState.enabled)
}

// optional .RecastIO.ShapeMode shapemode = 6 [default = SHAPE_TRIANGLES];
inline bool NodeState::has_shapemode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeState::set_has_shapemode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeState::clear_has_shapemode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeState::clear_shapemode() {
  shapemode_ = 0;
  clear_has_shapemode();
}
inline ::RecastIO::ShapeMode NodeState::shapemode() const {
  // @@protoc_insertion_point(field_get:RecastIO.NodeState.shapemode)
  return static_cast< ::RecastIO::ShapeMode >(shapemode_);
}
inline void NodeState::set_shapemode(::RecastIO::ShapeMode value) {
  assert(::RecastIO::ShapeMode_IsValid(value));
  set_has_shapemode();
  shapemode_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NodeState.shapemode)
}

// optional bool solid = 7 [default = true];
inline bool NodeState::has_solid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeState::set_has_solid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NodeState::clear_has_solid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NodeState::clear_solid() {
  solid_ = true;
  clear_has_solid();
}
inline bool NodeState::solid() const {
  // @@protoc_insertion_point(field_get:RecastIO.NodeState.solid)
  return solid_;
}
inline void NodeState::set_solid(bool value) {
  set_has_solid();
  solid_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NodeState.solid)
}

// optional bool dynamic = 8 [default = false];
inline bool NodeState::has_dynamic() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NodeState::set_has_dynamic() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NodeState::clear_has_dynamic() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NodeState::clear_dynamic() {
  dynamic_ = false;
  clear_has_dynamic();
}
inline bool NodeState::dynamic() const {
  // @@protoc_insertion_point(field_get:RecastIO.NodeState.dynamic)
  return dynamic_;
}
inline void NodeState::set_dynamic(bool value) {
  set_has_dynamic();
  dynamic_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NodeState.dynamic)
}

// optional uint64 navFlagOverride = 9 [default = 0];
inline bool NodeState::has_navflagoverride() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NodeState::set_has_navflagoverride() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NodeState::clear_has_navflagoverride() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NodeState::clear_navflagoverride() {
  navflagoverride_ = GOOGLE_ULONGLONG(0);
  clear_has_navflagoverride();
}
inline ::google::protobuf::uint64 NodeState::navflagoverride() const {
  // @@protoc_insertion_point(field_get:RecastIO.NodeState.navFlagOverride)
  return navflagoverride_;
}
inline void NodeState::set_navflagoverride(::google::protobuf::uint64 value) {
  set_has_navflagoverride();
  navflagoverride_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NodeState.navFlagOverride)
}

// optional uint32 activeModelCrc = 10 [default = 0];
inline bool NodeState::has_activemodelcrc() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NodeState::set_has_activemodelcrc() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NodeState::clear_has_activemodelcrc() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NodeState::clear_activemodelcrc() {
  activemodelcrc_ = 0u;
  clear_has_activemodelcrc();
}
inline ::google::protobuf::uint32 NodeState::activemodelcrc() const {
  // @@protoc_insertion_point(field_get:RecastIO.NodeState.activeModelCrc)
  return activemodelcrc_;
}
inline void NodeState::set_activemodelcrc(::google::protobuf::uint32 value) {
  set_has_activemodelcrc();
  activemodelcrc_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NodeState.activeModelCrc)
}

// optional string modelname = 11;
inline bool NodeState::has_modelname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NodeState::set_has_modelname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NodeState::clear_has_modelname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NodeState::clear_modelname() {
  if (modelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_->clear();
  }
  clear_has_modelname();
}
inline const ::std::string& NodeState::modelname() const {
  // @@protoc_insertion_point(field_get:RecastIO.NodeState.modelname)
  return *modelname_;
}
inline void NodeState::set_modelname(const ::std::string& value) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(value);
  // @@protoc_insertion_point(field_set:RecastIO.NodeState.modelname)
}
inline void NodeState::set_modelname(const char* value) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(value);
  // @@protoc_insertion_point(field_set_char:RecastIO.NodeState.modelname)
}
inline void NodeState::set_modelname(const char* value, size_t size) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RecastIO.NodeState.modelname)
}
inline ::std::string* NodeState::mutable_modelname() {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RecastIO.NodeState.modelname)
  return modelname_;
}
inline ::std::string* NodeState::release_modelname() {
  clear_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modelname_;
    modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NodeState::set_allocated_modelname(::std::string* modelname) {
  if (modelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modelname_;
  }
  if (modelname) {
    set_has_modelname();
    modelname_ = modelname;
  } else {
    clear_has_modelname();
    modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.NodeState.modelname)
}

// optional string name = 12;
inline bool NodeState::has_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NodeState::set_has_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NodeState::clear_has_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NodeState::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NodeState::name() const {
  // @@protoc_insertion_point(field_get:RecastIO.NodeState.name)
  return *name_;
}
inline void NodeState::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:RecastIO.NodeState.name)
}
inline void NodeState::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:RecastIO.NodeState.name)
}
inline void NodeState::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RecastIO.NodeState.name)
}
inline ::std::string* NodeState::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RecastIO.NodeState.name)
  return name_;
}
inline ::std::string* NodeState::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NodeState::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.NodeState.name)
}

inline bool NodeState::has_type() {
  return type_case() != TYPE_NOT_SET;
}
inline void NodeState::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline NodeState::TypeCase NodeState::type_case() const {
  return NodeState::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NavigationMesh

// required int32 version = 1;
inline bool NavigationMesh::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NavigationMesh::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NavigationMesh::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NavigationMesh::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 NavigationMesh::version() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavigationMesh.version)
  return version_;
}
inline void NavigationMesh::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavigationMesh.version)
}

// required .RecastIO.NavMeshParams navMeshParams = 2;
inline bool NavigationMesh::has_navmeshparams() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NavigationMesh::set_has_navmeshparams() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NavigationMesh::clear_has_navmeshparams() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NavigationMesh::clear_navmeshparams() {
  if (navmeshparams_ != NULL) navmeshparams_->::RecastIO::NavMeshParams::Clear();
  clear_has_navmeshparams();
}
inline const ::RecastIO::NavMeshParams& NavigationMesh::navmeshparams() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavigationMesh.navMeshParams)
  return navmeshparams_ != NULL ? *navmeshparams_ : *default_instance_->navmeshparams_;
}
inline ::RecastIO::NavMeshParams* NavigationMesh::mutable_navmeshparams() {
  set_has_navmeshparams();
  if (navmeshparams_ == NULL) navmeshparams_ = new ::RecastIO::NavMeshParams;
  // @@protoc_insertion_point(field_mutable:RecastIO.NavigationMesh.navMeshParams)
  return navmeshparams_;
}
inline ::RecastIO::NavMeshParams* NavigationMesh::release_navmeshparams() {
  clear_has_navmeshparams();
  ::RecastIO::NavMeshParams* temp = navmeshparams_;
  navmeshparams_ = NULL;
  return temp;
}
inline void NavigationMesh::set_allocated_navmeshparams(::RecastIO::NavMeshParams* navmeshparams) {
  delete navmeshparams_;
  navmeshparams_ = navmeshparams;
  if (navmeshparams) {
    set_has_navmeshparams();
  } else {
    clear_has_navmeshparams();
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.NavigationMesh.navMeshParams)
}

// repeated .RecastIO.AxisAlignedBounds exclusionZone = 3;
inline int NavigationMesh::exclusionzone_size() const {
  return exclusionzone_.size();
}
inline void NavigationMesh::clear_exclusionzone() {
  exclusionzone_.Clear();
}
inline const ::RecastIO::AxisAlignedBounds& NavigationMesh::exclusionzone(int index) const {
  // @@protoc_insertion_point(field_get:RecastIO.NavigationMesh.exclusionZone)
  return exclusionzone_.Get(index);
}
inline ::RecastIO::AxisAlignedBounds* NavigationMesh::mutable_exclusionzone(int index) {
  // @@protoc_insertion_point(field_mutable:RecastIO.NavigationMesh.exclusionZone)
  return exclusionzone_.Mutable(index);
}
inline ::RecastIO::AxisAlignedBounds* NavigationMesh::add_exclusionzone() {
  // @@protoc_insertion_point(field_add:RecastIO.NavigationMesh.exclusionZone)
  return exclusionzone_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::AxisAlignedBounds >&
NavigationMesh::exclusionzone() const {
  // @@protoc_insertion_point(field_list:RecastIO.NavigationMesh.exclusionZone)
  return exclusionzone_;
}
inline ::google::protobuf::RepeatedPtrField< ::RecastIO::AxisAlignedBounds >*
NavigationMesh::mutable_exclusionzone() {
  // @@protoc_insertion_point(field_mutable_list:RecastIO.NavigationMesh.exclusionZone)
  return &exclusionzone_;
}

// repeated .RecastIO.OffMeshConnection offMeshConnection = 4;
inline int NavigationMesh::offmeshconnection_size() const {
  return offmeshconnection_.size();
}
inline void NavigationMesh::clear_offmeshconnection() {
  offmeshconnection_.Clear();
}
inline const ::RecastIO::OffMeshConnection& NavigationMesh::offmeshconnection(int index) const {
  // @@protoc_insertion_point(field_get:RecastIO.NavigationMesh.offMeshConnection)
  return offmeshconnection_.Get(index);
}
inline ::RecastIO::OffMeshConnection* NavigationMesh::mutable_offmeshconnection(int index) {
  // @@protoc_insertion_point(field_mutable:RecastIO.NavigationMesh.offMeshConnection)
  return offmeshconnection_.Mutable(index);
}
inline ::RecastIO::OffMeshConnection* NavigationMesh::add_offmeshconnection() {
  // @@protoc_insertion_point(field_add:RecastIO.NavigationMesh.offMeshConnection)
  return offmeshconnection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::OffMeshConnection >&
NavigationMesh::offmeshconnection() const {
  // @@protoc_insertion_point(field_list:RecastIO.NavigationMesh.offMeshConnection)
  return offmeshconnection_;
}
inline ::google::protobuf::RepeatedPtrField< ::RecastIO::OffMeshConnection >*
NavigationMesh::mutable_offmeshconnection() {
  // @@protoc_insertion_point(field_mutable_list:RecastIO.NavigationMesh.offMeshConnection)
  return &offmeshconnection_;
}

// repeated .RecastIO.NodeState nodeState = 5;
inline int NavigationMesh::nodestate_size() const {
  return nodestate_.size();
}
inline void NavigationMesh::clear_nodestate() {
  nodestate_.Clear();
}
inline const ::RecastIO::NodeState& NavigationMesh::nodestate(int index) const {
  // @@protoc_insertion_point(field_get:RecastIO.NavigationMesh.nodeState)
  return nodestate_.Get(index);
}
inline ::RecastIO::NodeState* NavigationMesh::mutable_nodestate(int index) {
  // @@protoc_insertion_point(field_mutable:RecastIO.NavigationMesh.nodeState)
  return nodestate_.Mutable(index);
}
inline ::RecastIO::NodeState* NavigationMesh::add_nodestate() {
  // @@protoc_insertion_point(field_add:RecastIO.NavigationMesh.nodeState)
  return nodestate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::NodeState >&
NavigationMesh::nodestate() const {
  // @@protoc_insertion_point(field_list:RecastIO.NavigationMesh.nodeState)
  return nodestate_;
}
inline ::google::protobuf::RepeatedPtrField< ::RecastIO::NodeState >*
NavigationMesh::mutable_nodestate() {
  // @@protoc_insertion_point(field_mutable_list:RecastIO.NavigationMesh.nodeState)
  return &nodestate_;
}

// repeated .RecastIO.Model models = 6;
inline int NavigationMesh::models_size() const {
  return models_.size();
}
inline void NavigationMesh::clear_models() {
  models_.Clear();
}
inline const ::RecastIO::Model& NavigationMesh::models(int index) const {
  // @@protoc_insertion_point(field_get:RecastIO.NavigationMesh.models)
  return models_.Get(index);
}
inline ::RecastIO::Model* NavigationMesh::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:RecastIO.NavigationMesh.models)
  return models_.Mutable(index);
}
inline ::RecastIO::Model* NavigationMesh::add_models() {
  // @@protoc_insertion_point(field_add:RecastIO.NavigationMesh.models)
  return models_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::Model >&
NavigationMesh::models() const {
  // @@protoc_insertion_point(field_list:RecastIO.NavigationMesh.models)
  return models_;
}
inline ::google::protobuf::RepeatedPtrField< ::RecastIO::Model >*
NavigationMesh::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:RecastIO.NavigationMesh.models)
  return &models_;
}

// repeated .RecastIO.Tile tiles = 100;
inline int NavigationMesh::tiles_size() const {
  return tiles_.size();
}
inline void NavigationMesh::clear_tiles() {
  tiles_.Clear();
}
inline const ::RecastIO::Tile& NavigationMesh::tiles(int index) const {
  // @@protoc_insertion_point(field_get:RecastIO.NavigationMesh.tiles)
  return tiles_.Get(index);
}
inline ::RecastIO::Tile* NavigationMesh::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:RecastIO.NavigationMesh.tiles)
  return tiles_.Mutable(index);
}
inline ::RecastIO::Tile* NavigationMesh::add_tiles() {
  // @@protoc_insertion_point(field_add:RecastIO.NavigationMesh.tiles)
  return tiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::Tile >&
NavigationMesh::tiles() const {
  // @@protoc_insertion_point(field_list:RecastIO.NavigationMesh.tiles)
  return tiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::RecastIO::Tile >*
NavigationMesh::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:RecastIO.NavigationMesh.tiles)
  return &tiles_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace RecastIO

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::RecastIO::ShapeMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RecastIO::ShapeMode>() {
  return ::RecastIO::ShapeMode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_recast_2eproto__INCLUDED
